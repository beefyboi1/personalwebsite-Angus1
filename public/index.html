<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Angus Norden's Website</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: linear-gradient(135deg, #1e3c72, #2a5298);
        color: white;
        min-height: 100vh;
      }

      /* Navigation */
      nav {
        background: rgba(0, 0, 0, 0.4);
        padding: 15px 0;
        position: sticky;
        top: 0;
        z-index: 1000;
        backdrop-filter: blur(10px);
      }

      nav ul {
        list-style: none;
        display: flex;
        justify-content: center;
        gap: 30px;
        flex-wrap: wrap;
      }

      nav button {
        background: transparent;
        border: 2px solid rgba(255, 255, 255, 0.3);
        color: white;
        padding: 12px 30px;
        font-size: 16px;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 500;
      }

      nav button:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.6);
        transform: translateY(-2px);
      }

      nav button.active {
        background: linear-gradient(45deg, #ff6b6b, #ee5a24);
        border-color: #ff6b6b;
        box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
      }

      /* Page Sections */
      .page {
        display: none;
        padding: 40px 20px;
        min-height: calc(100vh - 80px);
      }

      .page.active {
        display: block;
        animation: fadeIn 0.5s ease-in;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* Home Page */
      #home-page {
        position: relative;
        overflow: hidden;
      }

      #starCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        cursor: pointer;
      }

      .home-page {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        max-width: 800px;
        margin: 0 auto;
        position: relative;
        z-index: 1;
        pointer-events: none; /* Allow clicks to pass through to canvas */
      }

      .home-page h1,
      .home-page p {
        pointer-events: none; /* Text is not clickable */
      }

      .home-page h1 {
        font-size: 3.5em;
        margin-bottom: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        animation: slideInDown 0.8s ease-out;
      }

      @keyframes slideInDown {
        from {
          opacity: 0;
          transform: translateY(-50px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .home-page p {
        font-size: 1.3em;
        margin-bottom: 40px;
        opacity: 0.9;
        animation: slideInUp 0.8s ease-out 0.2s both;
      }

      @keyframes slideInUp {
        from {
          opacity: 0;
          transform: translateY(50px);
        }
        to {
          opacity: 0.9;
          transform: translateY(0);
        }
      }

      /* About Me Page */
      .about-page {
        max-width: 900px;
        margin: 0 auto;
      }

      .about-page h1 {
        font-size: 2.5em;
        margin-bottom: 30px;
        text-align: center;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .about-content {
        background: rgba(0, 0, 0, 0.3);
        padding: 40px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        line-height: 1.8;
      }

      .about-content h2 {
        margin-top: 30px;
        margin-bottom: 15px;
        color: #ffd93d;
      }

      .about-content p {
        margin-bottom: 20px;
        font-size: 1.1em;
      }

      .about-content ul {
        margin-left: 30px;
        margin-bottom: 20px;
      }

      .about-content li {
        margin-bottom: 10px;
        font-size: 1.1em;
      }

      .cover-photo {
        width: 100%;
        max-width: 600px;
        height: auto;
        border-radius: 15px;
        margin: 0 auto 30px auto;
        display: block;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      }

      .about-content a {
        color: #ffd93d;
        text-decoration: none;
        font-weight: bold;
      }

      .about-content a:hover {
        text-decoration: underline;
      }

      /* Widgets Page */
      .widgets-page {
        max-width: 900px;
        margin: 0 auto;
      }

      .widgets-page h1 {
        font-size: 2.5em;
        margin-bottom: 30px;
        text-align: center;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .widgets-content {
        background: rgba(0, 0, 0, 0.3);
        padding: 40px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      }

      .widget-item {
        background: rgba(255, 255, 255, 0.1);
        padding: 25px;
        border-radius: 10px;
        margin-bottom: 20px;
        transition: all 0.3s ease;
      }

      .widget-item:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }

      .widget-item h2 {
        color: #ffd93d;
        margin-bottom: 15px;
        font-size: 1.5em;
      }

      .widget-item p {
        margin-bottom: 15px;
        font-size: 1.1em;
        line-height: 1.6;
      }

      .widget-item button {
        background: linear-gradient(45deg, #ff6b6b, #ee5a24);
        border: none;
        color: white;
        padding: 12px 30px;
        font-size: 16px;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        font-weight: 500;
      }

      .widget-item button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(255, 107, 107, 0.5);
        background: linear-gradient(45deg, #ee5a24, #ff6b6b);
      }

      /* Pulley Simulator Page */
      .pulley-container {
        text-align: center;
        background: rgba(0, 0, 0, 0.3);
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        max-width: 900px;
        margin: 0 auto;
      }

      .pulley-container h1 {
        margin: 0 0 20px 0;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .pulley-info {
        font-size: 18px;
        margin: 15px 0;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .pulley-info strong {
        color: #ffd93d;
      }

      #pulleyCanvas {
        border: 3px solid #fff;
        border-radius: 10px;
        background: #fff;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        margin: 20px 0;
      }

      .pulley-control {
        margin: 20px 0;
        font-size: 18px;
        color: white;
        text-align: center;
      }

      .pulley-control label {
        margin-right: 10px;
      }

      .pulley-control input[type="range"] {
        width: 200px;
        margin: 0 10px;
        accent-color: #ff6b6b;
      }

      .pulley-control span {
        font-weight: bold;
        color: #ffd93d;
      }

      .pulley-control button {
        background: linear-gradient(45deg, #3498db, #2980b9);
        border: 2px solid #3498db;
        color: white;
        padding: 10px 20px;
        font-size: 16px;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        font-weight: 500;
      }

      .pulley-control button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(52, 152, 219, 0.5);
        background: linear-gradient(45deg, #2980b9, #3498db);
      }

      .pulley-control button.active {
        background: linear-gradient(45deg, #27ae60, #2ecc71);
        border-color: #27ae60;
        box-shadow: 0 0 20px rgba(39, 174, 96, 0.5);
      }

      /* Pong Game Page */
      .pong-container {
        text-align: center;
        background: rgba(0, 0, 0, 0.3);
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        max-width: 900px;
        margin: 0 auto;
      }

      .pong-container h1 {
        margin: 0 0 20px 0;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .score {
        color: white;
        font-size: 1.5em;
        margin-bottom: 15px;
        font-weight: bold;
      }

      #gameCanvas {
        background: #000;
        border: 3px solid white;
        border-radius: 10px;
        display: block;
        margin: 0 auto;
      }

      .pong-controls {
        color: white;
        margin-top: 15px;
        font-size: 14px;
      }

      .start-screen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        color: white;
      }

      .game-over {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        color: white;
        display: none;
      }

      .game-over button {
        background: linear-gradient(45deg, #ffd93d, #ffed4e);
        border: 3px solid #ffd93d;
        color: #1e3c72;
        padding: 15px 35px;
        font-size: 18px;
        font-weight: bold;
        border-radius: 30px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 6px 25px rgba(255, 217, 61, 0.6);
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .game-over button:hover {
        transform: translateY(-3px) scale(1.05);
        box-shadow: 0 8px 30px rgba(255, 217, 61, 0.8);
        background: linear-gradient(45deg, #ffed4e, #ffd93d);
      }

      .game-over button:active {
        transform: translateY(-1px) scale(1.02);
      }

      .canvas-wrapper {
        position: relative;
        display: inline-block;
      }

      .speed-control {
        margin-top: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
        justify-content: center;
      }

      .speed-control label {
        color: white;
        font-weight: bold;
        min-width: 120px;
      }

      .speed-control input[type="range"] {
        flex: 1;
        max-width: 300px;
        accent-color: #ff6b6b;
      }

      .speed-control span {
        color: #ff6b6b;
        font-weight: bold;
        min-width: 30px;
        text-align: left;
      }

      .paddle-speed-control {
        margin-top: 10px;
        display: flex;
        align-items: center;
        gap: 10px;
        justify-content: center;
      }

      .paddle-speed-control label {
        color: white;
        font-weight: bold;
        min-width: 120px;
      }

      .paddle-speed-control input[type="range"] {
        flex: 1;
        max-width: 300px;
        accent-color: #3498db;
      }

      .paddle-speed-control span {
        color: #3498db;
        font-weight: bold;
        min-width: 30px;
        text-align: left;
      }

      .mode-control {
        margin-top: 15px;
      }

      .mode-control button {
        background: linear-gradient(45deg, #27ae60, #2ecc71);
        border: 2px solid #27ae60;
        color: white;
        padding: 10px 20px;
        font-size: 14px;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      }

      .mode-control button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        background: linear-gradient(45deg, #2ecc71, #27ae60);
      }

      .mode-control button.two-player {
        background: linear-gradient(45deg, #f39c12, #e67e22);
        border-color: #f39c12;
        box-shadow: 0 0 20px rgba(243, 156, 18, 0.5);
      }

      .hard-mode-control {
        margin-top: 10px;
      }

      .hard-mode-control button {
        background: linear-gradient(45deg, #2c3e50, #34495e);
        border: 2px solid #3498db;
        color: white;
        padding: 10px 20px;
        font-size: 14px;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      }

      .hard-mode-control button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        background: linear-gradient(45deg, #34495e, #2c3e50);
      }

      .hard-mode-control button.active {
        background: linear-gradient(45deg, #e74c3c, #c0392b);
        border-color: #e74c3c;
        box-shadow: 0 0 20px rgba(231, 76, 60, 0.5);
      }

      /* Leaderboard Styles */
      .leaderboard {
        margin-top: 30px;
        background: rgba(0, 0, 0, 0.3);
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }

      .leaderboard h2 {
        color: #ffd93d;
        margin-bottom: 15px;
        font-size: 1.8em;
        text-align: center;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .leaderboard-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
      }

      .leaderboard-table th {
        background: rgba(255, 217, 61, 0.2);
        color: #ffd93d;
        padding: 12px;
        text-align: left;
        font-weight: bold;
        border-bottom: 2px solid rgba(255, 217, 61, 0.4);
      }

      .leaderboard-table td {
        padding: 10px 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        color: white;
      }

      .leaderboard-table tr:hover {
        background: rgba(255, 255, 255, 0.05);
      }

      .leaderboard-table .rank {
        font-weight: bold;
        color: #ffd93d;
        width: 60px;
      }

      .leaderboard-table .name {
        font-weight: 500;
      }

      .leaderboard-table .hits {
        text-align: right;
        font-weight: bold;
        color: #ff6b6b;
      }

      .leaderboard-loading {
        text-align: center;
        color: rgba(255, 255, 255, 0.7);
        padding: 20px;
      }

      /* Neighborhoods Page */
      .neighborhoods-page {
        max-width: 1200px;
        margin: 0 auto;
      }

      .neighborhoods-page h1 {
        font-size: 2.5em;
        margin-bottom: 30px;
        text-align: center;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .neighborhoods-content {
        background: rgba(0, 0, 0, 0.3);
        padding: 40px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      }

      .loading {
        text-align: center;
        padding: 40px;
        font-size: 1.2em;
        color: #ffd93d;
      }

      .error {
        text-align: center;
        padding: 40px;
        font-size: 1.2em;
        color: #ff6b6b;
        background: rgba(255, 107, 107, 0.2);
        border-radius: 10px;
        margin-bottom: 20px;
      }

      .neighborhoods-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .neighborhood-card {
        background: rgba(255, 255, 255, 0.1);
        padding: 25px;
        border-radius: 10px;
        transition: all 0.3s ease;
        border: 2px solid rgba(255, 255, 255, 0.2);
      }

      .neighborhood-card:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: translateY(-5px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        border-color: rgba(255, 255, 255, 0.4);
      }

      .neighborhood-card h2 {
        color: #ffd93d;
        margin-bottom: 15px;
        font-size: 1.5em;
      }

      .neighborhood-card p {
        margin-bottom: 10px;
        font-size: 1em;
        line-height: 1.6;
      }

      .neighborhood-card .field-label {
        color: #ffd93d;
        font-weight: bold;
        margin-right: 8px;
      }

      .neighborhood-card .field-value {
        color: #fff;
      }

      .empty-state {
        text-align: center;
        padding: 60px 20px;
        color: rgba(255, 255, 255, 0.7);
        font-size: 1.2em;
      }

      .neighborhoods-map-container {
        width: 100%;
        margin-bottom: 30px;
        border-radius: 15px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        background: rgba(0, 0, 0, 0.3);
        position: relative;
      }

      #neighborhoods-map-image {
        width: 100%;
        height: auto;
        display: block;
      }

      .neighborhood-marker {
        position: absolute;
        width: 24px;
        height: 24px;
        cursor: pointer;
        transform: translate(-50%, -100%);
        z-index: 10;
      }

      .neighborhood-marker::before {
        content: '';
        position: absolute;
        width: 0;
        height: 0;
        border-left: 12px solid transparent;
        border-right: 12px solid transparent;
        border-top: 20px solid #ff6b6b;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
      }

      .neighborhood-marker::after {
        content: '';
        position: absolute;
        top: -20px;
        left: 50%;
        transform: translateX(-50%);
        width: 8px;
        height: 8px;
        background: #fff;
        border-radius: 50%;
        border: 2px solid #ff6b6b;
      }

      .neighborhood-marker:hover {
        z-index: 20;
      }

      .marker-tooltip {
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 14px;
        white-space: nowrap;
        margin-bottom: 5px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s;
        z-index: 30;
      }

      .neighborhood-marker:hover .marker-tooltip {
        opacity: 1;
      }

      /* Add Neighborhood Button */
      .add-neighborhood-btn {
        background: linear-gradient(45deg, #27ae60, #2ecc71);
        border: none;
        color: white;
        padding: 15px 30px;
        font-size: 18px;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        font-weight: 500;
        margin-bottom: 20px;
        display: block;
        margin-left: auto;
        margin-right: auto;
      }

      .add-neighborhood-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(39, 174, 96, 0.5);
        background: linear-gradient(45deg, #2ecc71, #27ae60);
      }

      /* Modal Styles */
      .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 2000;
        justify-content: center;
        align-items: center;
      }

      .modal-overlay.active {
        display: flex;
      }

      .modal-content {
        background: linear-gradient(135deg, #1e3c72, #2a5298);
        padding: 40px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        max-width: 500px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 30px;
      }

      .modal-header h2 {
        margin: 0;
        color: white;
        font-size: 2em;
      }

      .modal-close {
        background: transparent;
        border: 2px solid rgba(255, 255, 255, 0.3);
        color: white;
        width: 35px;
        height: 35px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
      }

      .modal-close:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.6);
      }

      .form-group {
        margin-bottom: 20px;
      }

      .form-group label {
        display: block;
        color: #ffd93d;
        margin-bottom: 8px;
        font-weight: bold;
        font-size: 1.1em;
      }

      .form-group input,
      .form-group textarea {
        width: 100%;
        padding: 12px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.3);
        color: white;
        font-size: 16px;
        font-family: inherit;
        box-sizing: border-box;
      }

      .form-group input:focus,
      .form-group textarea:focus {
        outline: none;
        border-color: #ffd93d;
        background: rgba(0, 0, 0, 0.5);
      }

      .form-group textarea {
        resize: vertical;
        min-height: 80px;
      }

      .form-group input[type="checkbox"] {
        width: auto;
        margin-right: 10px;
        cursor: pointer;
      }

      .checkbox-group {
        display: flex;
        align-items: center;
      }

      .checkbox-group label {
        margin-bottom: 0;
        cursor: pointer;
      }

      .form-group small {
        display: block;
        color: rgba(255, 255, 255, 0.7);
        margin-top: 5px;
        font-size: 0.9em;
      }

      .form-actions {
        display: flex;
        gap: 15px;
        margin-top: 30px;
      }

      .form-actions button {
        flex: 1;
        padding: 15px;
        border: none;
        border-radius: 25px;
        font-size: 16px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .btn-submit {
        background: linear-gradient(45deg, #27ae60, #2ecc71);
        color: white;
      }

      .btn-submit:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(39, 174, 96, 0.5);
      }

      .btn-cancel {
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: 2px solid rgba(255, 255, 255, 0.3);
      }

      .btn-cancel:hover {
        background: rgba(255, 255, 255, 0.3);
        border-color: rgba(255, 255, 255, 0.6);
      }

      .form-error {
        color: #ff6b6b;
        margin-top: 10px;
        font-size: 0.9em;
        display: none;
      }

      .form-error.active {
        display: block;
      }

      /* Accessed Page */
      .accessed-page {
        max-width: 1200px;
        margin: 0 auto;
      }

      .accessed-page h1 {
        font-size: 2.5em;
        margin-bottom: 30px;
        text-align: center;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .accessed-content {
        background: rgba(0, 0, 0, 0.3);
        padding: 40px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      }

      .accessed-list {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .accessed-item {
        background: rgba(255, 255, 255, 0.1);
        padding: 20px;
        border-radius: 10px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        transition: all 0.3s ease;
      }

      .accessed-item:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        border-color: rgba(255, 255, 255, 0.4);
      }

      .accessed-item .device-name {
        color: #ffd93d;
        font-size: 1.3em;
        font-weight: bold;
        margin-bottom: 8px;
      }

      .accessed-item .ip-address {
        color: #fff;
        font-size: 1.1em;
      }

      .accessed-item .ip-label {
        color: #ffd93d;
        font-weight: bold;
        margin-right: 8px;
      }

      /* Username Entry Modal - Blocks page until name is entered */
      .username-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        z-index: 10000;
        display: none;
        justify-content: center;
        align-items: center;
      }

      .username-modal-overlay.active {
        display: flex;
      }

      .username-modal-content {
        background: linear-gradient(135deg, #1e3c72, #2a5298);
        padding: 50px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        max-width: 500px;
        width: 90%;
        text-align: center;
      }

      .username-modal-content h2 {
        color: white;
        font-size: 2em;
        margin-bottom: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .username-modal-content p {
        color: rgba(255, 255, 255, 0.9);
        font-size: 1.1em;
        margin-bottom: 30px;
      }

      .username-input-group {
        margin-bottom: 20px;
      }

      .username-input-group input {
        width: 100%;
        padding: 15px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.3);
        color: white;
        font-size: 18px;
        font-family: inherit;
        box-sizing: border-box;
        text-align: center;
      }

      .username-input-group input:focus {
        outline: none;
        border-color: #ffd93d;
        background: rgba(0, 0, 0, 0.5);
      }

      .username-input-group input::placeholder {
        color: rgba(255, 255, 255, 0.5);
      }

      .username-submit-btn {
        background: linear-gradient(45deg, #27ae60, #2ecc71);
        border: none;
        color: white;
        padding: 15px 40px;
        font-size: 18px;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        font-weight: 500;
        width: 100%;
      }

      .username-submit-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(39, 174, 96, 0.5);
      }

      .username-submit-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .username-error {
        color: #ff6b6b;
        margin-top: 10px;
        font-size: 0.9em;
        display: none;
      }

      .username-error.active {
        display: block;
      }
    </style>
  </head>
  <body>
    <!-- Navigation -->
    <nav>
      <ul>
        <li>
          <button onclick="showPage('home')" id="nav-home" class="active">
            Home
          </button>
        </li>
        <li>
          <button onclick="showPage('about')" id="nav-about">About Me</button>
        </li>
        <li>
          <button onclick="showPage('widgets')" id="nav-widgets">
            Widgets
          </button>
        </li>
        <li>
          <button onclick="showPage('neighborhoods')" id="nav-neighborhoods">
            Neighborhoods
          </button>
        </li>
        <li>
          <button onclick="showPage('accessed')" id="nav-accessed">
            Accessed
          </button>
        </li>
      </ul>
    </nav>

    <!-- Home Page -->
    <div id="home-page" class="page active">
      <canvas id="starCanvas"></canvas>
      <div class="home-page">
        <h1>Welcome to Angus Norden's Website</h1>
        <p>Explore my portfolio and enjoy some interactive fun!</p>
        <p style="font-size: 0.9em; opacity: 0.7; margin-top: 20px">
          Click anywhere to fly forward through space!
        </p>
      </div>
    </div>

    <!-- About Me Page -->
    <div id="about-page" class="page">
      <div class="about-page">
        <h1>Angus Norden's About Me</h1>
        <div class="about-content">
          <img src="IMG_9461.jpg" alt="Angus Norden" class="cover-photo" />
          <h2>Hello!</h2>
          <p>
            Welcome to Angus Norden's personal website! I'm passionate about
            technology, programming, and creating interactive experiences. This
            website showcases some of my work and interests.
          </p>

          <h2>Projects</h2>
          <p>
            This website showcases some of my work and interests.
          </p>

          <h2>Get in Touch</h2>
          <p>
            If you'd like to connect, you can contact me at
            <a href="mailto:anorden1@hwemail.com">anorden1@hwemail.com</a>.
          </p>
        </div>
      </div>
    </div>

    <!-- Widgets Page -->
    <div id="widgets-page" class="page">
      <div class="widgets-page">
        <h1>Widgets</h1>
        <div class="widgets-content">
          <div class="widget-item">
            <h2>PulleySim (rope dreams come to life)</h2>
            <p>
              Explore a pulley system with mechanical advantage of 2, holding a
              1 kg mass.
            </p>
            <button onclick="showPage('pulley')">Open PulleySim</button>
          </div>
          <div class="widget-item">
            <h2>Pong Game</h2>
            <p>
              Classic Pong game with customizable speed, paddle controls, and multiple game modes.
            </p>
            <button onclick="showPage('pong')">Play Pong</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Neighborhoods Page -->
    <div id="neighborhoods-page" class="page">
      <div class="neighborhoods-page">
        <h1>Neighborhoods</h1>
        <button class="add-neighborhood-btn" onclick="openAddNeighborhoodModal()">
          + Add New Neighborhood
        </button>
        <div class="neighborhoods-map-container">
          <img id="neighborhoods-map-image" src="LAMap.png" alt="Los Angeles County Map" />
          <div id="neighborhoods-markers"></div>
        </div>
        <div class="neighborhoods-content">
          <div id="neighborhoods-loading" class="loading">
            Loading neighborhoods...
          </div>
          <div id="neighborhoods-error" class="error" style="display: none;"></div>
          <div id="neighborhoods-grid" class="neighborhoods-grid"></div>
        </div>
      </div>
    </div>

    <!-- Add Neighborhood Modal -->
    <div id="add-neighborhood-modal" class="modal-overlay">
      <div class="modal-content">
        <div class="modal-header">
          <h2>Add New Neighborhood</h2>
          <button class="modal-close" onclick="closeAddNeighborhoodModal()">&times;</button>
        </div>
        <form id="add-neighborhood-form">
          <div class="form-group">
            <label for="neighborhood-name">Neighborhood Name *</label>
            <input type="text" id="neighborhood-name" required placeholder="e.g., Downtown LA" />
          </div>
          <div class="form-group">
            <label for="neighborhood-population">Population</label>
            <input type="number" id="neighborhood-population" placeholder="e.g., 50000" />
          </div>
          <div class="form-group">
            <label for="neighborhood-location">Location (Coordinates)</label>
            <input type="text" id="neighborhood-location-lat" placeholder="Latitude (e.g., 34.0522)" />
            <input type="text" id="neighborhood-location-lng" placeholder="Longitude (e.g., -118.2437)" style="margin-top: 10px;" />
            <small>Enter coordinates as numbers, or leave blank</small>
          </div>
          <div class="form-group">
            <div class="checkbox-group">
              <input type="checkbox" id="neighborhood-isCool" />
              <label for="neighborhood-isCool">Is Cool</label>
            </div>
          </div>
          <div class="form-group">
            <label for="neighborhood-whoLivesThere">Who Lives There</label>
            <textarea id="neighborhood-whoLivesThere" placeholder="Describe who lives in this neighborhood"></textarea>
          </div>
          <div class="form-error" id="form-error"></div>
          <div class="form-actions">
            <button type="button" class="btn-cancel" onclick="closeAddNeighborhoodModal()">Cancel</button>
            <button type="submit" class="btn-submit">Add Neighborhood</button>
          </div>
        </form>
      </div>
    </div>

    <!-- Accessed Page -->
    <div id="accessed-page" class="page">
      <div class="accessed-page">
        <h1>Accessed</h1>
        <div class="accessed-content">
          <div id="accessed-loading" class="loading">
            Loading accessed users...
          </div>
          <div id="accessed-error" class="error" style="display: none;"></div>
          <div id="accessed-list" class="accessed-list"></div>
        </div>
      </div>
    </div>

    <!-- Username Entry Modal - Blocks page until name is entered -->
    <div id="username-modal" class="username-modal-overlay">
      <div class="username-modal-content">
        <h2>Welcome!</h2>
        <p>Please enter your name/username to continue:</p>
        <form id="username-form">
          <div class="username-input-group">
            <input 
              type="text" 
              id="username-input" 
              placeholder="Enter your name/username" 
              required 
              autofocus
              minlength="1"
            />
            <div class="username-error" id="username-error">Please enter a valid name/username</div>
          </div>
          <button type="submit" class="username-submit-btn" id="username-submit-btn">
            Continue
          </button>
        </form>
      </div>
    </div>

    <!-- Pulley Simulator Page -->
    <div id="pulley-page" class="page">
      <div class="pulley-container">
        <h1>PulleySim (rope dreams come to life)</h1>
        <div class="pulley-info">
          <strong>Mechanical Advantage:</strong>
          <span id="displayMA">1:1</span> | <strong>Mass:</strong>
          <span id="displayMass">1</span> kg | <strong>Force Required:</strong>
          <span id="displayForce">9.8</span> N
        </div>
        <canvas id="pulleyCanvas" width="800" height="500"></canvas>
        <div class="pulley-control">
          <label for="massSlider">Mass:</label>
          <input
            type="range"
            id="massSlider"
            min="0.5"
            max="5"
            value="1"
            step="0.1"
          />
          <span id="massValue">1</span> kg
        </div>
        <div class="pulley-control">
          <label for="maSlider">Mechanical Advantage:</label>
          <input
            type="range"
            id="maSlider"
            min="1"
            max="4"
            value="1"
            step="1"
          />
          <span id="maValue">1:1</span>
        </div>
        <div class="pulley-info">
          <p>
            This pulley system changes the direction of force but doesn't reduce
            the effort needed.
          </p>
          <p id="forceCalculation">Force = Weight = 1 kg × 9.8 m/s² = 9.8 N</p>
          <p>You pull down to lift the box up!</p>
        </div>
      </div>
    </div>

    <!-- Pong Game Page -->
    <div id="pong-page" class="page">
      <div class="pong-container">
        <h1>PONG</h1>
        <div class="score">
          You: <span id="player1Score">0</span> - Computer: <span id="player2Score">0</span>
        </div>
        <div class="score" style="margin-top: 10px; font-size: 1.2em;">
          Your High Score: <span id="playerHighScore">0</span> hits | Current Round: <span id="currentHits">0</span> hits
        </div>
        <div class="canvas-wrapper">
          <canvas id="gameCanvas" width="800" height="400"></canvas>
          <div class="start-screen" id="startScreen">
            <h2>Welcome to Pong!</h2>
            <p>First to 5 points wins!</p>
            <button onclick="startPongGame()">Start Game</button>
          </div>
          <div class="game-over" id="gameOver">
            <h2 id="gameOverText">Game Over!</h2>
            <p id="winnerText"></p>
            <button onclick="resetPongGame()">Play Again</button>
          </div>
        </div>
        <div class="pong-controls">
          Use W/S keys to move your paddle
        </div>
        <div class="speed-control">
          <label for="speedSlider">Ball Speed:</label>
          <input
            type="range"
            id="speedSlider"
            min="2"
            max="20"
            value="5"
            step="0.5"
          />
          <span id="speedValue">5</span>
        </div>
        <div class="paddle-speed-control">
          <label for="paddleSpeedSlider">Paddle Speed:</label>
          <input
            type="range"
            id="paddleSpeedSlider"
            min="2"
            max="10"
            value="6"
            step="0.5"
          />
          <span id="paddleSpeedValue">6</span>
        </div>
        <div class="mode-control">
          <button id="modeToggle" onclick="togglePlayerMode()">
            Mode: Single Player
          </button>
        </div>
        <div class="hard-mode-control">
          <button id="hardModeToggle" onclick="toggleHardMode()">
            Hard Mode: OFF
          </button>
        </div>
        <div class="leaderboard">
          <h2>Top 5 High Scores</h2>
          <div id="leaderboard-loading" class="leaderboard-loading">Loading leaderboard...</div>
          <table class="leaderboard-table" id="leaderboard-table" style="display: none;">
            <thead>
              <tr>
                <th class="rank">Rank</th>
                <th class="name">Name</th>
                <th class="hits">Score</th>
              </tr>
            </thead>
            <tbody id="leaderboard-body">
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
      // Import Firebase functions
      import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
      import { getFirestore, collection, getDocs, addDoc, doc, setDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

      // Firebase configuration
      // TODO: Replace with your Firebase project configuration
      // You can find this in Firebase Console > Project Settings > General > Your apps
      const firebaseConfig = {
        apiKey: "YOUR_API_KEY",
        authDomain: "personalwebsite-angus.firebaseapp.com",
        projectId: "personalwebsite-angus",
        storageBucket: "personalwebsite-angus.appspot.com",
        messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
        appId: "YOUR_APP_ID"
      };

      // Initialize Firebase
      let app;
      let db;
      
      try {
        app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        window.firestoreDb = db; // Make db available globally
      } catch (error) {
        console.error("Firebase initialization error:", error);
        window.firestoreDb = null;
      }

      // Cookie helper functions (make globally accessible)
      window.setCookie = function(name, value, days) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        const expires = "expires=" + date.toUTCString();
        document.cookie = name + "=" + value + ";" + expires + ";path=/";
      };

      window.getCookie = function(name) {
        const nameEQ = name + "=";
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++) {
          let c = ca[i];
          while (c.charAt(0) === ' ') c = c.substring(1, c.length);
          if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
      };

      // Function to get username from cookie
      function getUsername() {
        return window.getCookie('userUsername') || null;
      }

      // Function to set username in cookie
      function setUsername(username) {
        // Store in cookie (expires in 365 days)
        window.setCookie('userUsername', username, 365);
        // Also store in localStorage as backup
        localStorage.setItem('userUsername', username);
      }

      // Flag to track if form handler is already attached
      let usernameFormHandlerAttached = false;

      // Function to show username modal (mandatory)
      function showUsernameModal() {
        const modal = document.getElementById('username-modal');
        const input = document.getElementById('username-input');
        const form = document.getElementById('username-form');
        const errorEl = document.getElementById('username-error');
        
        if (!modal || !form) return;
        
        // Show modal
        modal.classList.add('active');
        
        // Clear any previous input
        input.value = '';
        errorEl.classList.remove('active');
        
        // Focus input
        setTimeout(() => {
          input.focus();
        }, 100);
        
        // Handle form submission (only attach once)
        if (!usernameFormHandlerAttached) {
          form.addEventListener('submit', (e) => {
            e.preventDefault();
            const username = input.value.trim();
            
            if (!username || username.length === 0) {
              errorEl.classList.add('active');
              return;
            }
            
            // Save username
            setUsername(username);
            
            // Hide modal
            modal.classList.remove('active');
            
            // Store IP after getting username
            setTimeout(() => {
              storeUserIP();
            }, 500);
          });
          usernameFormHandlerAttached = true;
        }
        
        // Prevent closing modal by clicking outside
        const preventClose = (e) => {
          if (e.target === modal) {
            e.preventDefault();
            e.stopPropagation();
          }
        };
        modal.addEventListener('click', preventClose);
        
        // Prevent ESC key from closing
        const preventEsc = (e) => {
          if (e.key === 'Escape' && modal.classList.contains('active')) {
            e.preventDefault();
            e.stopPropagation();
          }
        };
        document.addEventListener('keydown', preventEsc);
      }

      // Function to get device name from user agent
      function getDeviceName() {
        const ua = navigator.userAgent;
        let deviceName = "Unknown Device";
        
        // Try to extract device/browser info
        if (ua.includes("Windows")) {
          deviceName = "Windows Device";
        } else if (ua.includes("Mac")) {
          deviceName = "Mac Device";
        } else if (ua.includes("Linux")) {
          deviceName = "Linux Device";
        } else if (ua.includes("Android")) {
          deviceName = "Android Device";
        } else if (ua.includes("iPhone") || ua.includes("iPad")) {
          deviceName = "iOS Device";
        }
        
        // Add browser info
        if (ua.includes("Chrome") && !ua.includes("Edg")) {
          deviceName += " - Chrome";
        } else if (ua.includes("Firefox")) {
          deviceName += " - Firefox";
        } else if (ua.includes("Safari") && !ua.includes("Chrome")) {
          deviceName += " - Safari";
        } else if (ua.includes("Edg")) {
          deviceName += " - Edge";
        }
        
        // Add a unique identifier based on screen resolution and timezone
        const screenInfo = `${screen.width}x${screen.height}`;
        const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        const uniqueId = btoa(screenInfo + timezone).substring(0, 8);
        
        return `${deviceName} - ${uniqueId}`;
      }

      // Function to get IP address
      async function getUserIP() {
        try {
          // Try multiple IP services for reliability
          const services = [
            'https://api.ipify.org?format=json',
            'https://api64.ipify.org?format=json',
            'https://ipapi.co/json/'
          ];
          
          for (const service of services) {
            try {
              // Create a timeout promise
              const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Timeout')), 5000)
              );
              
              // Race between fetch and timeout
              const response = await Promise.race([
                fetch(service),
                timeoutPromise
              ]);
              
              const data = await response.json();
              
              // Different services return IP in different formats
              if (data.ip) {
                return data.ip;
              } else if (data.query) {
                return data.query;
              }
            } catch (e) {
              continue; // Try next service
            }
          }
          
          return "Unknown";
        } catch (error) {
          console.error("Error fetching IP:", error);
          return "Unknown";
        }
      }

      // Function to reset all cookies
      function resetAllCookies() {
        // Delete all cookies by setting them to expire in the past
        const cookies = document.cookie.split(';');
        cookies.forEach(cookie => {
          const eqPos = cookie.indexOf('=');
          const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim();
          if (name) {
            document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/';
          }
        });
        // Also clear localStorage
        localStorage.clear();
        console.log('All cookies and localStorage cleared');
      }

      // Function to store IP in Firestore
      async function storeUserIP() {
        // Check if username exists in cookie - if not, don't store
        const username = getUsername();
        if (!username) {
          console.log('No username found, cannot store IP');
          return;
        }

        if (!window.firestoreDb) {
          console.error('Firestore not initialized');
          return;
        }

        try {
          const deviceName = getDeviceName();
          const userIP = await getUserIP();
          
          // Import setDoc for setting document with custom ID
          const { setDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
          
          // Use device name as document ID (for uniqueness), but store username in the document
          const ipRef = doc(window.firestoreDb, 'IPs', deviceName);
          await setDoc(ipRef, {
            IP: userIP,
            username: username,
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            screenResolution: `${screen.width}x${screen.height}`,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
          }, { merge: true }); // Use merge to update if document exists
          
          console.log(`Stored IP ${userIP} for user ${username}`);
        } catch (error) {
          console.error('Error storing user IP:', error);
        }
      }

      // Check for username and show modal or store IP when page loads
      window.addEventListener('load', () => {
        const username = getUsername();
        
        if (!username) {
          // No username found - show mandatory modal
          setTimeout(() => {
            showUsernameModal();
          }, 100);
        } else {
          // Username exists - store IP (will update if already exists)
          setTimeout(() => {
            storeUserIP();
          }, 1000);
        }
      });

      // Make resetAllCookies available globally for testing/debugging
      window.resetAllCookies = resetAllCookies;

      // Function to load accessed users from Firestore
      window.loadAccessedUsers = async function() {
        const loadingEl = document.getElementById('accessed-loading');
        const errorEl = document.getElementById('accessed-error');
        const listEl = document.getElementById('accessed-list');

        if (!window.firestoreDb) {
          loadingEl.style.display = 'none';
          errorEl.style.display = 'block';
          errorEl.textContent = 'Firebase is not initialized. Please configure your Firebase credentials.';
          return;
        }

        try {
          loadingEl.style.display = 'block';
          errorEl.style.display = 'none';
          listEl.innerHTML = '';

          const ipsRef = collection(window.firestoreDb, 'IPs');
          const snapshot = await getDocs(ipsRef);

          loadingEl.style.display = 'none';

          if (snapshot.empty) {
            listEl.innerHTML = '<div class="empty-state">No users have accessed the website yet.</div>';
            return;
          }

          // Use a Map to deduplicate by username, keeping the most recent IP
          const uniqueUsers = new Map();
          
          snapshot.forEach((doc) => {
            const data = doc.data();
            const username = data.username || 'Anonymous';
            const ip = data.IP || 'Unknown';
            const timestamp = data.timestamp || '';
            
            // Use username as the key - if we've seen this username before, update with newer IP
            if (!uniqueUsers.has(username)) {
              uniqueUsers.set(username, {
                username: username,
                ip: ip,
                timestamp: timestamp
              });
            } else {
              // Compare timestamps to keep the most recent IP
              const existing = uniqueUsers.get(username);
              if (timestamp > existing.timestamp) {
                uniqueUsers.set(username, {
                  username: username,
                  ip: ip,
                  timestamp: timestamp
                });
              }
            }
          });

          // Convert map to array and sort by username
          const usersArray = Array.from(uniqueUsers.values())
            .map(user => ({ username: user.username, ip: user.ip })) // Remove timestamp from display
            .sort((a, b) => a.username.localeCompare(b.username));

          if (usersArray.length === 0) {
            listEl.innerHTML = '<div class="empty-state">No users have accessed the website yet.</div>';
            return;
          }

          // Display each unique user
          usersArray.forEach(user => {
            const item = document.createElement('div');
            item.className = 'accessed-item';
            item.innerHTML = `
              <div class="device-name">${user.username}</div>
              <div class="ip-address">
                <span class="ip-label">IP:</span>${user.ip}
              </div>
            `;
            listEl.appendChild(item);
          });
        } catch (error) {
          console.error('Error loading accessed users:', error);
          loadingEl.style.display = 'none';
          errorEl.style.display = 'block';
          errorEl.textContent = `Error loading accessed users: ${error.message}`;
        }
      };

      // Function to load neighborhoods from Firestore
      window.loadNeighborhoods = async function() {
        const loadingEl = document.getElementById('neighborhoods-loading');
        const errorEl = document.getElementById('neighborhoods-error');
        const gridEl = document.getElementById('neighborhoods-grid');

        if (!window.firestoreDb) {
          loadingEl.style.display = 'none';
          errorEl.style.display = 'block';
          errorEl.textContent = 'Firebase is not initialized. Please configure your Firebase credentials.';
          return;
        }

        try {
          loadingEl.style.display = 'block';
          errorEl.style.display = 'none';
          gridEl.innerHTML = '';

          const neighborhoodsRef = collection(window.firestoreDb, 'neighborhoods');
          const snapshot = await getDocs(neighborhoodsRef);

          loadingEl.style.display = 'none';

          if (snapshot.empty) {
            gridEl.innerHTML = '<div class="empty-state">No neighborhoods found in the database.</div>';
            return;
          }

          // Store neighborhoods data for map
          const neighborhoodsData = [];

          snapshot.forEach((doc) => {
            const data = doc.data();
            neighborhoodsData.push({ id: doc.id, data: data });
            const card = document.createElement('div');
            card.className = 'neighborhood-card';
            
            let cardContent = `<h2>${doc.id}</h2>`;
            
            // Define the order of fields to display - always show in this exact order
            const fieldOrder = ['population', 'location', 'isCool', 'whoLivesThere'];
            
            // Helper function to format and display a field
            const displayField = (key) => {
              const value = data[key];
              let displayValue = value;
              
              // Format the value based on its type
              if (value === null || value === undefined || !(key in data)) {
                displayValue = 'N/A';
              } else if (typeof value === 'object') {
                displayValue = JSON.stringify(value, null, 2);
              } else if (typeof value === 'boolean') {
                displayValue = value ? 'Yes' : 'No';
              }
              
              cardContent += `<p><span class="field-label">${key}:</span> <span class="field-value">${displayValue}</span></p>`;
            };
            
            // Always display fields in the specified order (even if missing, show N/A)
            fieldOrder.forEach(key => {
              displayField(key);
            });
            
            // Display any remaining fields that weren't in the ordered list
            Object.keys(data).forEach(key => {
              if (!fieldOrder.includes(key)) {
                displayField(key);
              }
            });
            
            card.innerHTML = cardContent;
            gridEl.appendChild(card);
          });
          
          // Initialize map with markers
          initializeNeighborhoodsMap(neighborhoodsData);
        } catch (error) {
          console.error('Error loading neighborhoods:', error);
          loadingEl.style.display = 'none';
          errorEl.style.display = 'block';
          errorEl.textContent = `Error loading neighborhoods: ${error.message}`;
        }
      };

      // Initialize custom map with LA.png image
      window.initializeNeighborhoodsMap = function(neighborhoodsData) {
        const mapImage = document.getElementById('neighborhoods-map-image');
        const markersContainer = document.getElementById('neighborhoods-markers');
        
        if (!mapImage || !markersContainer) {
          console.error('Map elements not found');
          return;
        }

        // Map bounds (from user specification)
        const topLeft = { lat: 34.282587, lng: -118.735801 };
        const bottomRight = { lat: 33.746624, lng: -118.119682 };
        
        // Function to convert lat/lng to pixel coordinates
        const latLngToPixel = (lat, lng, imageWidth, imageHeight) => {
          // Calculate percentage from bounds
          const lngPercent = (lng - topLeft.lng) / (bottomRight.lng - topLeft.lng);
          const latPercent = (topLeft.lat - lat) / (topLeft.lat - bottomRight.lat);
          
          // Convert to pixel coordinates
          const x = lngPercent * imageWidth;
          const y = latPercent * imageHeight;
          
          return { x, y };
        };

        // Function to extract coordinates from location data
        const getCoordinates = (location) => {
          if (!location || location === 'N/A') return null;
          
          // Check if location is coordinates object
          if (typeof location === 'object' && location !== null) {
            if (location.lat !== undefined && location.lng !== undefined) {
              return { lat: location.lat, lng: location.lng };
            } else if (location.latitude !== undefined && location.longitude !== undefined) {
              return { lat: location.latitude, lng: location.longitude };
            }
          }
          
          return null;
        };

        // Function to create marker on image
        const createMarker = (pixelX, pixelY, neighborhood) => {
          const marker = document.createElement('div');
          marker.className = 'neighborhood-marker';
          marker.style.left = pixelX + 'px';
          marker.style.top = pixelY + 'px';
          
          // Create tooltip
          const tooltip = document.createElement('div');
          tooltip.className = 'marker-tooltip';
          tooltip.textContent = neighborhood.id;
          marker.appendChild(tooltip);
          
          // Add click handler to show info
          marker.addEventListener('click', () => {
            const info = `
              Neighborhood: ${neighborhood.id}
              ${neighborhood.data.population ? `Population: ${neighborhood.data.population}` : ''}
              ${neighborhood.data.location ? `Location: ${JSON.stringify(neighborhood.data.location)}` : ''}
              ${neighborhood.data.isCool !== undefined ? `Is Cool: ${neighborhood.data.isCool ? 'Yes' : 'No'}` : ''}
            `;
            alert(info);
          });
          
          markersContainer.appendChild(marker);
        };

        // Wait for image to load to get its dimensions
        const placeMarkers = () => {
          const imageWidth = mapImage.offsetWidth;
          const imageHeight = mapImage.offsetHeight;
          
          // Clear existing markers
          markersContainer.innerHTML = '';
          
          // Add markers for each neighborhood
          neighborhoodsData.forEach(neighborhood => {
            const location = neighborhood.data.location;
            const coords = getCoordinates(location);
            
            if (coords) {
              // Check if coordinates are within bounds
              if (coords.lat >= bottomRight.lat && coords.lat <= topLeft.lat &&
                  coords.lng >= topLeft.lng && coords.lng <= bottomRight.lng) {
                const pixelPos = latLngToPixel(coords.lat, coords.lng, imageWidth, imageHeight);
                createMarker(pixelPos.x, pixelPos.y, neighborhood);
              } else {
                console.warn(`Coordinates for ${neighborhood.id} are outside map bounds`);
              }
            }
          });
        };

        // Place markers when image loads or if already loaded
        if (mapImage.complete) {
          placeMarkers();
        } else {
          mapImage.addEventListener('load', placeMarkers);
        }
        
        // Also place markers on window resize to adjust for image size changes
        let resizeTimeout;
        window.addEventListener('resize', () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(placeMarkers, 250);
        });
      };

      // Modal functions for adding neighborhoods
      window.openAddNeighborhoodModal = function() {
        const modal = document.getElementById('add-neighborhood-modal');
        if (modal) {
          modal.classList.add('active');
          // Reset form
          document.getElementById('add-neighborhood-form').reset();
          document.getElementById('form-error').classList.remove('active');
        }
      };

      window.closeAddNeighborhoodModal = function() {
        const modal = document.getElementById('add-neighborhood-modal');
        if (modal) {
          modal.classList.remove('active');
        }
      };

      // Close modal when clicking outside
      document.addEventListener('DOMContentLoaded', () => {
        const modal = document.getElementById('add-neighborhood-modal');
        if (modal) {
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              closeAddNeighborhoodModal();
            }
          });
        }

        // Handle form submission
        const form = document.getElementById('add-neighborhood-form');
        if (form) {
          form.addEventListener('submit', async (e) => {
            e.preventDefault();
            await handleAddNeighborhood();
          });
        }
      });

      // Function to add neighborhood to Firestore
      window.handleAddNeighborhood = async function() {
        const errorEl = document.getElementById('form-error');
        const submitBtn = document.querySelector('#add-neighborhood-form .btn-submit');
        
        if (!window.firestoreDb) {
          errorEl.textContent = 'Firebase is not initialized. Please configure your Firebase credentials.';
          errorEl.classList.add('active');
          return;
        }

        // Get form values
        const name = document.getElementById('neighborhood-name').value.trim();
        const population = document.getElementById('neighborhood-population').value.trim();
        const locationLat = document.getElementById('neighborhood-location-lat').value.trim();
        const locationLng = document.getElementById('neighborhood-location-lng').value.trim();
        const isCool = document.getElementById('neighborhood-isCool').checked;
        const whoLivesThere = document.getElementById('neighborhood-whoLivesThere').value.trim();

        // Validate name
        if (!name) {
          errorEl.textContent = 'Neighborhood name is required.';
          errorEl.classList.add('active');
          return;
        }

        // Build data object
        const neighborhoodData = {};

        if (population) {
          neighborhoodData.population = parseInt(population) || 0;
        }

        // Handle location - create object if both lat and lng are provided
        if (locationLat && locationLng) {
          const lat = parseFloat(locationLat);
          const lng = parseFloat(locationLng);
          if (!isNaN(lat) && !isNaN(lng)) {
            neighborhoodData.location = { lat: lat, lng: lng };
          }
        }

        neighborhoodData.isCool = isCool;

        if (whoLivesThere) {
          neighborhoodData.whoLivesThere = whoLivesThere;
        }

        try {
          // Disable submit button
          submitBtn.disabled = true;
          submitBtn.textContent = 'Adding...';
          errorEl.classList.remove('active');

          // Add document with custom ID (neighborhood name)
          const { setDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
          const neighborhoodRef = doc(window.firestoreDb, 'neighborhoods', name);
          await setDoc(neighborhoodRef, neighborhoodData);

          // Success - close modal and reload neighborhoods
          closeAddNeighborhoodModal();
          
          // Reload neighborhoods
          if (window.loadNeighborhoods) {
            await window.loadNeighborhoods();
          }

          // Show success message (optional)
          alert(`Neighborhood "${name}" added successfully!`);
        } catch (error) {
          console.error('Error adding neighborhood:', error);
          errorEl.textContent = `Error adding neighborhood: ${error.message}`;
          errorEl.classList.add('active');
        } finally {
          // Re-enable submit button
          submitBtn.disabled = false;
          submitBtn.textContent = 'Add Neighborhood';
        }
      };
    </script>

    <script>
      // Navigation functionality
      function showPage(pageId) {
        // Hide all pages
        document.querySelectorAll(".page").forEach((page) => {
          page.classList.remove("active");
        });

        // Remove active class from all nav buttons
        document.querySelectorAll("nav button").forEach((btn) => {
          btn.classList.remove("active");
        });

        // Show selected page
        const selectedPage = document.getElementById(pageId + "-page");
        if (selectedPage) {
          selectedPage.classList.add("active");
        }

        // Add active class to corresponding nav button
        const navButton = document.getElementById("nav-" + pageId);
        if (navButton) {
          navButton.classList.add("active");
        }

        // Initialize starry sky if showing home page
        if (pageId === "home") {
          setTimeout(() => {
            initStarField();
          }, 100);
        }

        // Initialize pulley canvas if showing pulley page
        if (pageId === "pulley") {
          setTimeout(() => {
            drawPulleySystem();
          }, 100);
        }

        // Initialize pong game if showing pong page
        if (pageId === "pong") {
          setTimeout(() => {
            initPongGame();
            loadPongLeaderboard();
            // Initialize user's leaderboard entry (creates with score 0 if doesn't exist)
            setTimeout(() => {
              initializeUserLeaderboardEntry();
            }, 500);
          }, 100);
        }

        // Load neighborhoods if showing neighborhoods page
        if (pageId === "neighborhoods") {
          setTimeout(() => {
            if (window.loadNeighborhoods) {
              window.loadNeighborhoods();
            }
          }, 100);
        }

        // Load accessed users if showing accessed page
        if (pageId === "accessed") {
          setTimeout(() => {
            if (window.loadAccessedUsers) {
              window.loadAccessedUsers();
            }
          }, 100);
        }
      }

      // Mass slider functionality for pulley system
      const massSlider = document.getElementById("massSlider");
      const massValue = document.getElementById("massValue");
      const displayMass = document.getElementById("displayMass");
      const displayForce = document.getElementById("displayForce");
      const forceCalculation = document.getElementById("forceCalculation");

      if (massSlider) {
        massSlider.addEventListener("input", function () {
          const mass = parseFloat(this.value);
          updatePulleyDisplay(mass, mechanicalAdvantage);
          drawPulleySystem(mass, mechanicalAdvantage);
        });
      }

      // Mechanical advantage slider functionality
      const maSlider = document.getElementById("maSlider");
      const maValue = document.getElementById("maValue");

      if (maSlider) {
        maSlider.addEventListener("input", function () {
          mechanicalAdvantage = parseInt(this.value);
          if (maValue) maValue.textContent = mechanicalAdvantage + ":1";
          updatePulleyDisplay(currentMass, mechanicalAdvantage);
          drawPulleySystem(currentMass, mechanicalAdvantage);
        });
      }

      // Update display values
      function updatePulleyDisplay(mass, ma) {
        if (massValue) massValue.textContent = mass.toFixed(1);
        if (displayMass) displayMass.textContent = mass.toFixed(1);

        // Calculate force based on mechanical advantage
        const weight = mass * 9.8;
        const force = weight / ma;

        if (displayForce) displayForce.textContent = force.toFixed(1);
        if (displayMA) displayMA.textContent = ma + ":1";

        // Update force calculation text
        if (forceCalculation) {
          if (ma === 1) {
            forceCalculation.textContent = `Force = Weight = ${mass.toFixed(
              1
            )} kg × 9.8 m/s² = ${force.toFixed(1)} N`;
          } else {
            forceCalculation.textContent = `Force = Weight ÷ MA = (${mass.toFixed(
              1
            )} kg × 9.8 m/s²) ÷ ${ma} = ${force.toFixed(1)} N`;
          }
        }
      }

      // Starry Sky Animation
      let starCanvas, starCtx;
      let stars = [];
      let velocity = { x: 0, y: 0, z: 0 };
      let currentSpeed = 0;
      let maxSpeed = 30;
      let lightSpeedMax = 80; // Much faster for click-and-hold
      let isFlying = false;
      let flyDuration = 3000; // 3 seconds
      let flyStartTime = 0;
      let lastTime = 0;
      let mousePressed = false;
      let targetDirection = { x: 0, y: 0 };
      let mouseDistanceFromCenter = 0; // Track distance from center for angle scaling
      let acceleration = 50; // Speed up quickly
      let deceleration = 80; // Slow down quickly
      let clickStartTime = 0;
      let isClickAndHold = false;

      function initStarField() {
        starCanvas = document.getElementById("starCanvas");
        if (!starCanvas) return;

        starCtx = starCanvas.getContext("2d");
        resizeStarCanvas();

        // Create stars - more stars, distributed across a wider area with more on edges
        stars = [];
        const numStars = 2000;
        const expandFactor = 2.0; // Expand star field beyond screen edges

        for (let i = 0; i < numStars; i++) {
          // Bias distribution toward edges - use radial distribution
          const angle = Math.random() * Math.PI * 2;
          const centerDist = Math.random(); // 0 to 1
          // Square it to bias toward edges (edge stars have larger distances)
          const edgeBias = Math.pow(centerDist, 0.4); // Lower exponent = more edge bias
          const distance =
            edgeBias *
            Math.max(starCanvas.width, starCanvas.height) *
            expandFactor;

          // Assign star colors - red, blue, or yellow
          const colorType = Math.random();
          let starColor;
          if (colorType < 0.33) {
            // Red stars (red-orange hues)
            starColor = `hsl(${Math.random() * 30 + 0}, 100%, ${
              Math.random() * 20 + 70
            }%)`;
          } else if (colorType < 0.66) {
            // Blue stars (blue-white hues)
            starColor = `hsl(${Math.random() * 60 + 180}, 100%, ${
              Math.random() * 15 + 80
            }%)`;
          } else {
            // Yellow stars (yellow-white hues, like our sun)
            starColor = `hsl(${Math.random() * 30 + 40}, 100%, ${
              Math.random() * 20 + 75
            }%)`;
          }

          stars.push({
            // Create stars in a wider area, biased toward edges
            x: Math.cos(angle) * distance + starCanvas.width / 2,
            y: Math.sin(angle) * distance + starCanvas.height / 2,
            z: Math.random() * 2000 + 500, // Depth range 500-2500
            size: Math.random() * 4.5 + 1.5, // Bigger stars: 1.5 to 6.0
            opacity: Math.random() * 0.7 + 0.6, // Brighter: 0.6 to 1.3 (clamped in rendering)
            color: starColor,
          });
        }

        // Helper function to update direction based on mouse position
        const updateDirectionFromMouse = function(e) {
          const rect = starCanvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;

          const centerX = starCanvas.width / 2;
          const centerY = starCanvas.height / 2;

          // Calculate direction vector from center to mouse position
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // Store distance from center for angle scaling
          mouseDistanceFromCenter = distance;

          // Normalize and store target direction
          if (distance > 0) {
            targetDirection.x = dx / distance;
            targetDirection.y = dy / distance;
          } else {
            targetDirection.x = 0;
            targetDirection.y = 0;
            mouseDistanceFromCenter = 0;
          }
        };

        // Mouse down handler - start flying in direction of click
        starCanvas.addEventListener("mousedown", function (e) {
          mousePressed = true;
          clickStartTime = performance.now();
          isClickAndHold = false;

          // Update direction from initial click position
          updateDirectionFromMouse(e);

          isFlying = true;
          flyStartTime = performance.now();
        });

        // Mouse move handler - update direction while mouse is pressed
        starCanvas.addEventListener("mousemove", function (e) {
          if (mousePressed) {
            // Update direction based on current mouse position
            updateDirectionFromMouse(e);
          }
        });

        // Mouse up handler - stop flying and slow down quickly
        starCanvas.addEventListener("mouseup", function (e) {
          const holdDuration = performance.now() - clickStartTime;
          mousePressed = false;

          // If it was a quick click (less than 200ms), do a quick burst
          if (!isClickAndHold && holdDuration < 200) {
            // Quick click - small burst of speed
            currentSpeed = Math.min(maxSpeed, currentSpeed + maxSpeed * 0.6);
            flyStartTime = performance.now();
          } else {
            // Was a hold, now decelerate
            flyStartTime = performance.now();
          }
        });

        // Mouse leave handler - stop flying if mouse leaves canvas
        starCanvas.addEventListener("mouseleave", function (e) {
          mousePressed = false;
          flyStartTime = performance.now();
        });

        animateStars(performance.now());
      }

      function resizeStarCanvas() {
        if (!starCanvas) return;
        const homePage = document.getElementById("home-page");
        if (homePage && homePage.classList.contains("active")) {
          starCanvas.width = window.innerWidth;
          starCanvas.height = window.innerHeight;

          // Recreate stars if canvas was resized
          if (stars.length > 0) {
            const expandFactor = 2.0;
            stars.forEach((star) => {
              // Recreate with edge bias, preserve color
              const angle = Math.random() * Math.PI * 2;
              const centerDist = Math.random();
              const edgeBias = Math.pow(centerDist, 0.4);
              const distance =
                edgeBias *
                Math.max(starCanvas.width, starCanvas.height) *
                expandFactor;
              star.x = Math.cos(angle) * distance + starCanvas.width / 2;
              star.y = Math.sin(angle) * distance + starCanvas.height / 2;
              star.z = Math.random() * 2000 + 500;
              // Keep existing color
            });
          }
        }
      }

      function animateStars(timestamp) {
        if (!starCtx || !starCanvas) return;

        // Use current time if timestamp not provided
        const currentTime = timestamp || performance.now();
        if (lastTime === 0) lastTime = currentTime;

        // Clear canvas with black space background
        starCtx.fillStyle = "#000000";
        starCtx.fillRect(0, 0, starCanvas.width, starCanvas.height);

        // Update flying state with acceleration/deceleration
        if (isFlying) {
          const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
          const holdDuration = currentTime - clickStartTime;

          if (mousePressed) {
            // Check if this is a click-and-hold (held for more than 150ms)
            if (holdDuration > 150 && !isClickAndHold) {
              isClickAndHold = true;
              // Switch to light speed mode
            }

            // Use light speed max if holding, regular max for quick clicks
            const activeMaxSpeed = isClickAndHold ? lightSpeedMax : maxSpeed;
            const activeAcceleration = isClickAndHold
              ? acceleration * 1.5
              : acceleration;

            // Accelerate quickly to max speed
            currentSpeed = Math.min(
              activeMaxSpeed,
              currentSpeed + activeAcceleration * deltaTime
            );

            // Calculate angle scaling factor based on distance from center
            // Max distance is approximately half the diagonal of the canvas
            const maxDistance = Math.sqrt(starCanvas.width * starCanvas.width + starCanvas.height * starCanvas.height) / 2;
            const normalizedDistance = Math.min(mouseDistanceFromCenter / maxDistance, 1);
            
            // Apply non-linear scaling: square the normalized distance to make extreme positions more extreme
            // Then scale from 0.4 (center) to 1.2 (far edges) for more dramatic angles
            const angleMultiplier = 0.4 + (normalizedDistance * normalizedDistance * 0.8);
            
            // Increase vertical sensitivity slightly for more noticeable up/down movement
            const verticalMultiplier = angleMultiplier * 1.1; // 10% more sensitive vertically
            
            // Update velocity based on current speed and target direction with angle scaling
            velocity.z = currentSpeed;
            velocity.x = targetDirection.x * currentSpeed * angleMultiplier;
            velocity.y = targetDirection.y * currentSpeed * verticalMultiplier;
          } else {
            // Decelerate quickly
            currentSpeed = Math.max(0, currentSpeed - deceleration * deltaTime);

            if (currentSpeed <= 0) {
              // Completely stopped
              isFlying = false;
              currentSpeed = 0;
              velocity.x = 0;
              velocity.y = 0;
              velocity.z = 0;
              isClickAndHold = false;
            } else {
              // Calculate angle scaling factor based on last known distance from center
              const maxDistance = Math.sqrt(starCanvas.width * starCanvas.width + starCanvas.height * starCanvas.height) / 2;
              const normalizedDistance = Math.min(mouseDistanceFromCenter / maxDistance, 1);
              const angleMultiplier = 0.4 + (normalizedDistance * normalizedDistance * 0.8);
              
              // Increase vertical sensitivity slightly for more noticeable up/down movement
              const verticalMultiplier = angleMultiplier * 1.1; // 10% more sensitive vertically
              
              // Maintain direction while slowing
              velocity.z = currentSpeed;
              velocity.x = targetDirection.x * currentSpeed * angleMultiplier;
              velocity.y = targetDirection.y * currentSpeed * verticalMultiplier;
            }
          }
        }

        // Update and draw stars
        const centerX = starCanvas.width / 2;
        const centerY = starCanvas.height / 2;

        for (let i = 0; i < stars.length; i++) {
          const star = stars[i];

          if (isFlying) {
            // Move stars based on velocity (reverse movement for flying effect)
            star.x -= velocity.x;
            star.y -= velocity.y;
            star.z -= velocity.z;
          }

          // Reset stars that have passed us or gone too far - bias toward edges
          if (star.z <= 0 || star.z > 3000) {
            const expandFactor = 2.0;
            const angle = Math.random() * Math.PI * 2;
            const centerDist = Math.random();
            const edgeBias = Math.pow(centerDist, 0.4);
            const distance =
              edgeBias *
              Math.max(starCanvas.width, starCanvas.height) *
              expandFactor;
            star.x = centerX + Math.cos(angle) * distance;
            star.y = centerY + Math.sin(angle) * distance;
            star.z = 2000 + Math.random() * 500;

            // Reassign color when resetting
            const colorType = Math.random();
            if (colorType < 0.33) {
              star.color = `hsl(${Math.random() * 30 + 0}, 100%, ${
                Math.random() * 20 + 70
              }%)`;
            } else if (colorType < 0.66) {
              star.color = `hsl(${Math.random() * 60 + 180}, 100%, ${
                Math.random() * 15 + 80
              }%)`;
            } else {
              star.color = `hsl(${Math.random() * 30 + 40}, 100%, ${
                Math.random() * 20 + 75
              }%)`;
            }
          }

          // Calculate 3D position with perspective
          const k = 128 / Math.max(star.z, 1); // Perspective factor
          const px = (star.x - centerX) * k + centerX;
          const py = (star.y - centerY) * k + centerY;
          const r = star.size * k;

          // Draw star if it's visible (even if slightly off screen for edge stars)
          if (r > 0.1) {
            // Calculate streak effect based on speed (Star Wars hyperspace effect)
            // Use lightSpeedMax for ratio calculation to show streaks at light speed
            const effectiveMaxSpeed = Math.max(maxSpeed, lightSpeedMax);
            const speedRatio = currentSpeed / effectiveMaxSpeed;
            const streakLength = speedRatio * r * 15; // Long streaks at high speed

            // Convert HSL color to RGBA with opacity
            const tempDiv = document.createElement("div");
            tempDiv.style.color = star.color;
            document.body.appendChild(tempDiv);
            const rgbColor = window.getComputedStyle(tempDiv).color;
            document.body.removeChild(tempDiv);

            // Extract RGB values
            const rgbMatch = rgbColor.match(/\d+/g);
            let red, green, blue;
            if (rgbMatch) {
              red = parseInt(rgbMatch[0]);
              green = parseInt(rgbMatch[1]);
              blue = parseInt(rgbMatch[2]);
            } else {
              red = 255;
              green = 255;
              blue = 255;
            }

            // Star gets brighter as it approaches
            const brightness = Math.min(
              1,
              Math.max(0.4, (3000 - star.z) / 700)
            );
            const finalOpacity = Math.min(1, star.opacity * brightness * 1.3);

            if (speedRatio > 0.7 && streakLength > 5) {
              // Draw hyperspace streak effect
              // Calculate streak direction (opposite of velocity, toward center)
              const streakDirX =
                (px - centerX) /
                Math.max(
                  1,
                  Math.sqrt(
                    (px - centerX) * (px - centerX) +
                      (py - centerY) * (py - centerY)
                  )
                );
              const streakDirY =
                (py - centerY) /
                Math.max(
                  1,
                  Math.sqrt(
                    (px - centerX) * (px - centerX) +
                      (py - centerY) * (py - centerY)
                  )
                );

              // Draw streak line
              starCtx.beginPath();
              starCtx.moveTo(px, py);
              starCtx.lineTo(
                px - streakDirX * streakLength,
                py - streakDirY * streakLength
              );
              starCtx.strokeStyle = `rgba(${red}, ${green}, ${blue}, ${
                finalOpacity * 0.9
              })`;
              starCtx.lineWidth = Math.max(1, r * 0.5);
              starCtx.stroke();

              // Draw bright head of streak
              starCtx.beginPath();
              starCtx.arc(px, py, r * 1.2, 0, Math.PI * 2);
              starCtx.fillStyle = `rgba(${red}, ${green}, ${blue}, ${finalOpacity})`;
              starCtx.fill();

              // Add intense glow at high speeds
              starCtx.shadowBlur = r * 6 * speedRatio;
              starCtx.shadowColor = `rgba(${red}, ${green}, ${blue}, 1.0)`;
              starCtx.fill();
              starCtx.shadowBlur = 0;
            } else {
              // Normal star rendering (slower speeds)
              starCtx.beginPath();
              starCtx.arc(px, py, r, 0, Math.PI * 2);
              starCtx.fillStyle = `rgba(${red}, ${green}, ${blue}, ${finalOpacity})`;
              starCtx.fill();

              // Add glow for closer stars
              if (r > 0.8) {
                const glowOpacity = Math.min(1, finalOpacity * 0.8);
                const blurRadius = r * 4;
                starCtx.shadowBlur = blurRadius;
                starCtx.shadowColor = `rgba(${red}, ${green}, ${blue}, ${glowOpacity})`;
                starCtx.fill();
                starCtx.shadowBlur = 0;
              }
            }
          }
        }

        requestAnimationFrame(animateStars);
        lastTime = currentTime;
      }

      // Handle window resize
      window.addEventListener("resize", function () {
        resizeStarCanvas();
      });

      // Initialize star field on page load if home page is active
      window.addEventListener("load", function () {
        const homePage = document.getElementById("home-page");
        if (homePage && homePage.classList.contains("active")) {
          setTimeout(() => {
            initStarField();
          }, 100);
        }
      });

      // Pulley System Drawing
      let currentMass = 1; // Default mass in kg
      let mechanicalAdvantage = 1; // 1:1 or 2:1

      function drawPulleySystem(mass = currentMass, ma = mechanicalAdvantage) {
        const canvas = document.getElementById("pulleyCanvas");
        if (!canvas) return;

        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;

        currentMass = mass; // Update current mass
        mechanicalAdvantage = ma; // Update mechanical advantage

        // Clear canvas with white background
        ctx.fillStyle = "#f0f0f0";
        ctx.fillRect(0, 0, width, height);

        // Draw ceiling
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(100, 50);
        ctx.lineTo(700, 50);
        ctx.stroke();

        // One fixed pulley on top (centered) - bigger diameter
        const fixedPulleyX = 400;
        const fixedPulleyY = 100;
        const fixedPulleyRadius = 50; // Bigger diameter

        // Mount dimensions (will be drawn last)
        const mountWidth = 15;
        const mountHeight = 110;

        // Draw fixed pulley (solid grey, no stroke)
        ctx.fillStyle = "#888";
        ctx.beginPath();
        ctx.arc(fixedPulleyX, fixedPulleyY, fixedPulleyRadius, 0, Math.PI * 2);
        ctx.fill();

        const massWidth = 80;
        const massHeight = 60;

        if (ma === 1) {
          // 1:1 Mechanical Advantage (Direction Changer)
          // Left side - where mass hangs (rope goes straight down from pulley)
          const leftRopeX = fixedPulleyX - fixedPulleyRadius;
          const massY = 350;

          // Right side - where you pull (rope goes straight down from pulley) - shorter
          const rightRopeX = fixedPulleyX + fixedPulleyRadius;
          const pullEndY = 320;

          // Draw left rope first (brown)
          ctx.strokeStyle = "#8B4513";
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.moveTo(leftRopeX, fixedPulleyY);
          ctx.lineTo(leftRopeX, massY);
          ctx.stroke();

          // Draw rope connection point on box
          ctx.fillStyle = "#8B4513";
          ctx.beginPath();
          ctx.arc(leftRopeX, massY, 3, 0, Math.PI * 2);
          ctx.fill();

          // Draw rope around top of pulley (semicircle from left to right) - brown
          ctx.strokeStyle = "#8B4513";
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.arc(fixedPulleyX, fixedPulleyY, fixedPulleyRadius, Math.PI, 0);
          ctx.stroke();

          // Draw right rope LAST - BROWN, goes straight down from pulley edge (shorter)
          ctx.strokeStyle = "#8B4513";
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.moveTo(rightRopeX, fixedPulleyY);
          ctx.lineTo(rightRopeX, pullEndY);
          ctx.stroke();

          // Draw mass/box hanging from left side
          ctx.fillStyle = "#444";
          ctx.strokeStyle = "#222";
          ctx.lineWidth = 2;
          ctx.fillRect(leftRopeX - massWidth / 2, massY, massWidth, massHeight);
          ctx.strokeRect(
            leftRopeX - massWidth / 2,
            massY,
            massWidth,
            massHeight
          );

          // Draw mass label on box (dynamic)
          ctx.fillStyle = "#fff";
          ctx.font = "bold 20px Arial";
          ctx.textAlign = "center";
          ctx.fillText(
            mass.toFixed(1) + " kg",
            leftRopeX,
            massY + massHeight / 2 + 7
          );

          // Draw arrow showing downward pull (on right side rope) - BROWN
          ctx.fillStyle = "#8B4513";
          ctx.beginPath();
          ctx.moveTo(rightRopeX, pullEndY + 30);
          ctx.lineTo(rightRopeX - 5, pullEndY + 20);
          ctx.lineTo(rightRopeX + 5, pullEndY + 20);
          ctx.closePath();
          ctx.fill();

          // Draw force labels (dynamic based on mass)
          const force = mass * 9.8; // Force = mass × gravity
          ctx.fillStyle = "#000";
          ctx.font = "16px Arial";
          ctx.textAlign = "center";
          ctx.fillText(
            "Force = " + force.toFixed(1) + " N",
            rightRopeX,
            pullEndY + 60
          );

          // Draw labels
          ctx.fillStyle = "#000";
          ctx.font = "14px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Fixed Pulley", fixedPulleyX, 30);

          // Draw mechanical advantage indicator
          ctx.fillStyle = "#0066cc";
          ctx.font = "bold 16px Arial";
          ctx.textAlign = "left";
          ctx.fillText(
            "Mechanical Advantage: 1:1 (Direction Changer)",
            20,
            height - 30
          );

          // Draw pulley mount LAST - rectangle centered on the pulley circle - BLACK
          // This ensures it appears on top of everything
          ctx.fillStyle = "#000";
          ctx.fillRect(
            fixedPulleyX - mountWidth / 2,
            fixedPulleyY - mountHeight / 2,
            mountWidth,
            mountHeight
          );
        } else if (ma === 2) {
          // 2:1 Mechanical Advantage
          // Movable pulley at bottom
          const movablePulleyX = fixedPulleyX;
          const movablePulleyY = 280;
          const movablePulleyRadius = 35;

          // Draw all grey circles FIRST (in background)
          ctx.fillStyle = "#888";
          // Draw movable pulley
          ctx.beginPath();
          ctx.arc(
            movablePulleyX,
            movablePulleyY,
            movablePulleyRadius,
            0,
            Math.PI * 2
          );
          ctx.fill();

          // Attachment point on mount (center, where rope attaches at top)
          const mountAttachmentY = fixedPulleyY - mountHeight / 2 + 20;

          // Pulling point (where the free end of rope hangs, right side)
          const pullRopeX = fixedPulleyX + fixedPulleyRadius + 80;
          const pullEndY = 340;

          // Draw rope path for 2:1 mechanical advantage
          ctx.strokeStyle = "#8B4513";
          ctx.lineWidth = 5;

          // Rope from mount attachment point wrapping around left side of top pulley
          // Draw line from mount to left side (avoiding the top), then arc along top semicircle

          // Now draw the arc along the top semicircle from left to top
          ctx.beginPath();
          ctx.moveTo(fixedPulleyX - fixedPulleyRadius, fixedPulleyY);
          // Arc along top semicircle from left to top (left half of top semicircle)
          ctx.arc(
            fixedPulleyX,
            fixedPulleyY,
            fixedPulleyRadius,
            Math.PI, // Left side (180°)
            (3 * Math.PI) / 2, // Top (270°)
            false // Counterclockwise - goes from left to top along top semicircle
          );
          ctx.stroke();

          // Rope path: from left side of top pulley down, around bottom of bottom pulley, then up
          ctx.beginPath();
          // Start from left side of top pulley
          ctx.moveTo(fixedPulleyX - fixedPulleyRadius, fixedPulleyY);
          // Straight down to left side of bottom pulley
          ctx.lineTo(movablePulleyX - movablePulleyRadius, movablePulleyY);
          // Semicircle around bottom of bottom pulley (bottom half only)
          // Arc from left (180°) through bottom (270°) to right (0°) - this is the bottom semicircle
          ctx.arc(
            movablePulleyX,
            movablePulleyY,
            movablePulleyRadius,
            Math.PI, // Left side (180°)
            0, // Right side (0°)
            true // Clockwise - goes from left through bottom (270°) to right (bottom semicircle)
          );
          // Straight up to mount attachment point
          ctx.lineTo(fixedPulleyX, mountAttachmentY);
          ctx.stroke();

          // Rope from mount attachment point wrapping around right side of top pulley
          // Draw line from mount to top of pulley, then arc along right half of top semicircle
          ctx.beginPath();
          ctx.moveTo(fixedPulleyX, mountAttachmentY);
          ctx.lineTo(fixedPulleyX, fixedPulleyY - fixedPulleyRadius);
          // Arc along right half of top semicircle: from top (270°) to right (0°)
          // This is 90 degrees along the top semicircle
          ctx.arc(
            fixedPulleyX,
            fixedPulleyY,
            fixedPulleyRadius,
            (3 * Math.PI) / 2, // Top (270°)
            0, // Right side (0°)
            false // Counterclockwise - goes from top to right along top semicircle
          );
          ctx.stroke();

          // Free end: diagonally down from right side of top pulley to pulling point
          ctx.beginPath();
          ctx.moveTo(fixedPulleyX + fixedPulleyRadius, fixedPulleyY);
          ctx.lineTo(pullRopeX, pullEndY);
          ctx.stroke();

          // Rope from movable pulley down to weight (separate rope hanging from bottom pulley)
          const massY = movablePulleyY + movablePulleyRadius + 20;
          ctx.strokeStyle = "#8B4513";
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.moveTo(movablePulleyX, movablePulleyY + movablePulleyRadius);
          ctx.lineTo(movablePulleyX, massY);
          ctx.stroke();

          // Draw mass/box hanging from bottom pulley
          ctx.fillStyle = "#444";
          ctx.strokeStyle = "#222";
          ctx.lineWidth = 2;
          ctx.fillRect(
            movablePulleyX - massWidth / 2,
            massY,
            massWidth,
            massHeight
          );
          ctx.strokeRect(
            movablePulleyX - massWidth / 2,
            massY,
            massWidth,
            massHeight
          );

          // Draw mass label on box (dynamic)
          ctx.fillStyle = "#fff";
          ctx.font = "bold 20px Arial";
          ctx.textAlign = "center";
          ctx.fillText(
            mass.toFixed(1) + " kg",
            movablePulleyX,
            massY + massHeight / 2 + 7
          );

          // Draw arrow showing downward pull (on free end of rope) - BROWN
          ctx.fillStyle = "#8B4513";
          ctx.beginPath();
          ctx.moveTo(pullRopeX, pullEndY + 30);
          ctx.lineTo(pullRopeX - 5, pullEndY + 20);
          ctx.lineTo(pullRopeX + 5, pullEndY + 20);
          ctx.closePath();
          ctx.fill();

          // Draw force labels (dynamic based on mass - Force = Weight / MA)
          const force = (mass * 9.8) / ma; // Force = (mass × gravity) / mechanical advantage
          ctx.fillStyle = "#000";
          ctx.font = "16px Arial";
          ctx.textAlign = "center";
          ctx.fillText(
            "Force = " + force.toFixed(1) + " N",
            pullRopeX,
            pullEndY + 60
          );

          // Draw labels
          ctx.fillStyle = "#000";
          ctx.font = "14px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Fixed Pulley", fixedPulleyX, 30);

          // Draw "Movable Pulley" label to the left of the bottom pulley
          ctx.textAlign = "right";
          ctx.fillText(
            "Movable Pulley",
            movablePulleyX - movablePulleyRadius - 10,
            movablePulleyY
          );

          // Draw mechanical advantage indicator
          ctx.fillStyle = "#0066cc";
          ctx.font = "bold 16px Arial";
          ctx.textAlign = "left";
          ctx.fillText("Mechanical Advantage: " + ma + ":1", 20, height - 30);

          // Draw pulley mount LAST - rectangle centered on the pulley circle - BLACK
          // This ensures it appears on top of everything
          ctx.fillStyle = "#000";
          ctx.fillRect(
            fixedPulleyX - mountWidth / 2,
            fixedPulleyY - mountHeight / 2,
            mountWidth,
            mountHeight
          );
        } else if (ma === 3) {
          // 3:1 Mechanical Advantage
          // Movable pulley at bottom
          const movablePulleyX = fixedPulleyX;
          const movablePulleyY = 320; // Lowered from 280
          const movablePulleyRadius = 35;

          // Define smaller pulley position (needed for rope path)
          const bottomMountWidth = 15;
          const bottomMountHeight = 70; // Height of the rectangle on the bottom pulley
          const ropeWidth = 5; // Width of the brown rope
          const gapSize = ropeWidth * 2; // Gap between the two top pulleys (2 times rope width)
          const smallerPulleyRadius = 30;
          // Position smaller pulley so gap is between edges (not centers)
          // Top pulley bottom edge + gap + smaller pulley radius = smaller pulley center
          const smallerPulleyY =
            fixedPulleyY + fixedPulleyRadius + gapSize + smallerPulleyRadius;

          // Draw all grey circles FIRST (in background)
          ctx.fillStyle = "#888";
          // Draw movable pulley
          ctx.beginPath();
          ctx.arc(
            movablePulleyX,
            movablePulleyY,
            movablePulleyRadius,
            0,
            Math.PI * 2
          );
          ctx.fill();
          // Draw smaller grey circle below the fixed pulley
          ctx.beginPath();
          ctx.arc(
            fixedPulleyX,
            smallerPulleyY,
            smallerPulleyRadius,
            0,
            Math.PI * 2
          );
          ctx.fill();

          // Attachment point on mount (center, where rope attaches at top)
          const mountAttachmentY = fixedPulleyY - mountHeight / 2 + 20;

          // Pulling point (where the free end of rope hangs, right side)
          const pullRopeX = fixedPulleyX + fixedPulleyRadius + 80;
          const pullEndY = 340;

          // Draw rope path for 3:1 mechanical advantage
          ctx.strokeStyle = "#8B4513";
          ctx.lineWidth = 5;

          // Rope from mount attachment point wrapping around left side of top pulley
          // Draw line from mount to left side (avoiding the top), then arc along top semicircle

          // Now draw the arc along the top semicircle from left to top
          ctx.beginPath();
          ctx.moveTo(fixedPulleyX - fixedPulleyRadius, fixedPulleyY);
          // Arc along top semicircle from left to top (left half of top semicircle)
          ctx.arc(
            fixedPulleyX,
            fixedPulleyY,
            fixedPulleyRadius,
            Math.PI, // Left side (180°)
            (3 * Math.PI) / 2, // Top (270°)
            false // Counterclockwise - goes from left to top along top semicircle
          );
          ctx.stroke();

          // Rope path: from left side of top pulley down, around bottom of bottom pulley, then up
          ctx.beginPath();
          // Start from left side of top pulley
          ctx.moveTo(fixedPulleyX - fixedPulleyRadius, fixedPulleyY);
          // Straight down to left side of bottom pulley
          ctx.lineTo(movablePulleyX - movablePulleyRadius, movablePulleyY);
          // Semicircle around bottom of bottom pulley (bottom half only)
          // Arc from left (180°) through bottom (270°) to right (0°) - this is the bottom semicircle
          ctx.arc(
            movablePulleyX,
            movablePulleyY,
            movablePulleyRadius,
            Math.PI, // Left side (180°)
            0, // Right side (0°)
            true // Clockwise - goes from left through bottom (270°) to right (bottom semicircle)
          );
          // Straight up to right side of smallest grey circle (below top fixed pulley)
          ctx.lineTo(fixedPulleyX + smallerPulleyRadius, smallerPulleyY);
          ctx.stroke();

          // Rope from mount attachment point wrapping around right side of top pulley
          // Draw line from mount to top of pulley, then arc along right half of top semicircle
          ctx.beginPath();
          ctx.moveTo(fixedPulleyX, mountAttachmentY);
          ctx.lineTo(fixedPulleyX, fixedPulleyY - fixedPulleyRadius);
          // Arc along right half of top semicircle: from top (270°) to right (0°)
          // This is 90 degrees along the top semicircle
          ctx.arc(
            fixedPulleyX,
            fixedPulleyY,
            fixedPulleyRadius,
            (3 * Math.PI) / 2, // Top (270°)
            0, // Right side (0°)
            false // Counterclockwise - goes from top to right along top semicircle
          );
          ctx.stroke();

          // Free end: from right side of top grey circle (fixed pulley) to pulling point
          ctx.beginPath();
          ctx.moveTo(fixedPulleyX + fixedPulleyRadius, fixedPulleyY);
          ctx.lineTo(pullRopeX, pullEndY);
          ctx.stroke();

          // Rope from movable pulley down to weight (separate rope hanging from bottom pulley)
          const massY = movablePulleyY + movablePulleyRadius + 20;
          ctx.strokeStyle = "#8B4513";
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.moveTo(movablePulleyX, movablePulleyY + movablePulleyRadius);
          ctx.lineTo(movablePulleyX, massY);
          ctx.stroke();

          // Draw mass/box hanging from bottom pulley
          ctx.fillStyle = "#444";
          ctx.strokeStyle = "#222";
          ctx.lineWidth = 2;
          ctx.fillRect(
            movablePulleyX - massWidth / 2,
            massY,
            massWidth,
            massHeight
          );
          ctx.strokeRect(
            movablePulleyX - massWidth / 2,
            massY,
            massWidth,
            massHeight
          );

          // Draw mass label on box (dynamic)
          ctx.fillStyle = "#fff";
          ctx.font = "bold 20px Arial";
          ctx.textAlign = "center";
          ctx.fillText(
            mass.toFixed(1) + " kg",
            movablePulleyX,
            massY + massHeight / 2 + 7
          );

          // Draw arrow showing downward pull (on free end of rope) - BROWN
          ctx.fillStyle = "#8B4513";
          ctx.beginPath();
          ctx.moveTo(pullRopeX, pullEndY + 30);
          ctx.lineTo(pullRopeX - 5, pullEndY + 20);
          ctx.lineTo(pullRopeX + 5, pullEndY + 20);
          ctx.closePath();
          ctx.fill();

          // Draw force labels (dynamic based on mass - Force = Weight / MA)
          const force = (mass * 9.8) / ma; // Force = (mass × gravity) / mechanical advantage
          ctx.fillStyle = "#000";
          ctx.font = "16px Arial";
          ctx.textAlign = "center";
          ctx.fillText(
            "Force = " + force.toFixed(1) + " N",
            pullRopeX,
            pullEndY + 60
          );

          // Draw labels
          ctx.fillStyle = "#000";
          ctx.font = "14px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Fixed Pulley", fixedPulleyX, 30);

          // Draw "Movable Pulley" label to the left of the bottom pulley
          ctx.textAlign = "right";
          ctx.fillText(
            "Movable Pulley",
            movablePulleyX - movablePulleyRadius - 10,
            movablePulleyY
          );

          // Draw mechanical advantage indicator
          ctx.fillStyle = "#0066cc";
          ctx.font = "bold 16px Arial";
          ctx.textAlign = "left";
          ctx.fillText("Mechanical Advantage: " + ma + ":1", 20, height - 30);

          // Rope semicircle around top of smallest grey circle (from right to left)
          ctx.strokeStyle = "#8B4513";
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.moveTo(fixedPulleyX + smallerPulleyRadius, smallerPulleyY);
          // Arc along top semicircle from right (0°) to left (180°)
          // Split into two arcs: right to top, then top to left
          // First arc: from right (0°) to top (270°) going counterclockwise
          ctx.arc(
            fixedPulleyX,
            smallerPulleyY,
            smallerPulleyRadius,
            0, // Right side (0°)
            (3 * Math.PI) / 2, // Top (270°)
            true // Counterclockwise - goes from right through top
          );
          // Second arc: from top (270°) to left (180°) going counterclockwise
          ctx.arc(
            fixedPulleyX,
            smallerPulleyY,
            smallerPulleyRadius,
            (3 * Math.PI) / 2, // Top (270°)
            Math.PI, // Left side (180°)
            true // Counterclockwise - goes from top to left
          );
          ctx.stroke();

          // Brown line from left side of middle grey circle to center of bottom grey circle
          ctx.beginPath();
          ctx.moveTo(fixedPulleyX - smallerPulleyRadius, smallerPulleyY); // Left side of middle circle
          ctx.lineTo(movablePulleyX, movablePulleyY); // Center of bottom circle
          ctx.stroke();

          // Draw extended pulley mount - rectangle that covers both pulleys with gap - BLACK
          const extendedMountHeight =
            smallerPulleyY +
            smallerPulleyRadius -
            (fixedPulleyY - mountHeight / 2);
          ctx.fillStyle = "#000";
          ctx.fillRect(
            fixedPulleyX - mountWidth / 2,
            fixedPulleyY - mountHeight / 2,
            mountWidth,
            extendedMountHeight
          );

          // Draw black rectangle vertically on the bottom movable pulley LAST (only for 3:1)
          // This ensures it appears on top of everything including the rope
          ctx.fillStyle = "#000";
          ctx.fillRect(
            movablePulleyX - bottomMountWidth / 2,
            movablePulleyY - bottomMountHeight / 2,
            bottomMountWidth,
            bottomMountHeight
          );
        } else if (ma === 4) {
          // 4:1 Mechanical Advantage
          // Movable pulley at bottom
          const movablePulleyX = fixedPulleyX;
          const movablePulleyY = 360; // Lowered further for 4:1
          const movablePulleyRadius = 35;

          // Define smaller pulley position (needed for rope path)
          const bottomMountWidth = 15;
          const bottomMountHeight = 70; // Height of the rectangle on the bottom pulley
          const ropeWidth = 5; // Width of the brown rope
          const gapSize = ropeWidth * 2; // Gap between the two top pulleys (2 times rope width)
          const smallerPulleyRadius = 30;
          // Position smaller pulley so gap is between edges (not centers)
          // Top pulley bottom edge + gap + smaller pulley radius = smaller pulley center
          const smallerPulleyY =
            fixedPulleyY + fixedPulleyRadius + gapSize + smallerPulleyRadius;

          // Define smaller pulley above bottom movable pulley (only for 4:1)
          const smallerBottomPulleyRadius = 25; // Smaller radius than bottom pulley
          // Position smaller bottom pulley so gap is between edges (not centers)
          // Bottom pulley top edge - gap - smaller pulley radius = smaller pulley center
          const smallerBottomPulleyY =
            movablePulleyY -
            movablePulleyRadius -
            gapSize -
            smallerBottomPulleyRadius;

          // Draw all grey circles FIRST (in background)
          ctx.fillStyle = "#888";
          // Draw smaller grey circle above bottom movable pulley
          ctx.beginPath();
          ctx.arc(
            movablePulleyX,
            smallerBottomPulleyY,
            smallerBottomPulleyRadius,
            0,
            Math.PI * 2
          );
          ctx.fill();
          // Draw movable pulley
          ctx.beginPath();
          ctx.arc(
            movablePulleyX,
            movablePulleyY,
            movablePulleyRadius,
            0,
            Math.PI * 2
          );
          ctx.fill();
          // Draw smaller grey circle below the fixed pulley
          ctx.beginPath();
          ctx.arc(
            fixedPulleyX,
            smallerPulleyY,
            smallerPulleyRadius,
            0,
            Math.PI * 2
          );
          ctx.fill();

          // Attachment point on mount (center, where rope attaches at top)
          const mountAttachmentY = fixedPulleyY - mountHeight / 2 + 20;

          // Pulling point (where the free end of rope hangs, right side)
          const pullRopeX = fixedPulleyX + fixedPulleyRadius + 80;
          const pullEndY = 340;

          // Draw rope path for 4:1 mechanical advantage
          ctx.strokeStyle = "#8B4513";
          ctx.lineWidth = 5;

          // Rope from mount attachment point wrapping around left side of top pulley
          // Draw line from mount to left side (avoiding the top), then arc along top semicircle

          // Now draw the arc along the top semicircle from left to top
          ctx.beginPath();
          ctx.moveTo(fixedPulleyX - fixedPulleyRadius, fixedPulleyY);
          // Arc along top semicircle from left to top (left half of top semicircle)
          ctx.arc(
            fixedPulleyX,
            fixedPulleyY,
            fixedPulleyRadius,
            Math.PI, // Left side (180°)
            (3 * Math.PI) / 2, // Top (270°)
            false // Counterclockwise - goes from left to top along top semicircle
          );
          ctx.stroke();

          // Rope path: from left side of top pulley down, around bottom of bottom pulley, then up
          ctx.beginPath();
          // Start from left side of top pulley
          ctx.moveTo(fixedPulleyX - fixedPulleyRadius, fixedPulleyY);
          // Straight down to left side of bottom pulley
          ctx.lineTo(movablePulleyX - movablePulleyRadius, movablePulleyY);
          // Semicircle around bottom of bottom pulley (bottom half only)
          // Arc from left (180°) through bottom (270°) to right (0°) - this is the bottom semicircle
          ctx.arc(
            movablePulleyX,
            movablePulleyY,
            movablePulleyRadius,
            Math.PI, // Left side (180°)
            0, // Right side (0°)
            true // Clockwise - goes from left through bottom (270°) to right (bottom semicircle)
          );
          // Straight up to right side of smallest grey circle (below top fixed pulley)
          ctx.lineTo(fixedPulleyX + smallerPulleyRadius, smallerPulleyY);
          ctx.stroke();

          // Rope from mount attachment point wrapping around right side of top pulley
          // Draw line from mount to top of pulley, then arc along right half of top semicircle
          ctx.beginPath();
          ctx.moveTo(fixedPulleyX, mountAttachmentY);
          ctx.lineTo(fixedPulleyX, fixedPulleyY - fixedPulleyRadius);
          // Arc along right half of top semicircle: from top (270°) to right (0°)
          // This is 90 degrees along the top semicircle
          ctx.arc(
            fixedPulleyX,
            fixedPulleyY,
            fixedPulleyRadius,
            (3 * Math.PI) / 2, // Top (270°)
            0, // Right side (0°)
            false // Counterclockwise - goes from top to right along top semicircle
          );
          ctx.stroke();

          // Free end: from right side of top grey circle (fixed pulley) to pulling point
          ctx.beginPath();
          ctx.moveTo(fixedPulleyX + fixedPulleyRadius, fixedPulleyY);
          ctx.lineTo(pullRopeX, pullEndY);
          ctx.stroke();

          // Rope from movable pulley down to weight (separate rope hanging from bottom pulley)
          const massY = movablePulleyY + movablePulleyRadius + 20;
          ctx.strokeStyle = "#8B4513";
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.moveTo(movablePulleyX, movablePulleyY + movablePulleyRadius);
          ctx.lineTo(movablePulleyX, massY);
          ctx.stroke();

          // Draw mass/box hanging from bottom pulley
          ctx.fillStyle = "#444";
          ctx.strokeStyle = "#222";
          ctx.lineWidth = 2;
          ctx.fillRect(
            movablePulleyX - massWidth / 2,
            massY,
            massWidth,
            massHeight
          );
          ctx.strokeRect(
            movablePulleyX - massWidth / 2,
            massY,
            massWidth,
            massHeight
          );

          // Draw mass label on box (dynamic)
          ctx.fillStyle = "#fff";
          ctx.font = "bold 20px Arial";
          ctx.textAlign = "center";
          ctx.fillText(
            mass.toFixed(1) + " kg",
            movablePulleyX,
            massY + massHeight / 2 + 7
          );

          // Draw arrow showing downward pull (on free end of rope) - BROWN
          ctx.fillStyle = "#8B4513";
          ctx.beginPath();
          ctx.moveTo(pullRopeX, pullEndY + 30);
          ctx.lineTo(pullRopeX - 5, pullEndY + 20);
          ctx.lineTo(pullRopeX + 5, pullEndY + 20);
          ctx.closePath();
          ctx.fill();

          // Draw force labels (dynamic based on mass - Force = Weight / MA)
          const force = (mass * 9.8) / ma; // Force = (mass × gravity) / mechanical advantage
          ctx.fillStyle = "#000";
          ctx.font = "16px Arial";
          ctx.textAlign = "center";
          ctx.fillText(
            "Force = " + force.toFixed(1) + " N",
            pullRopeX,
            pullEndY + 60
          );

          // Draw labels
          ctx.fillStyle = "#000";
          ctx.font = "14px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Fixed Pulley", fixedPulleyX, 30);

          // Draw "Movable Pulley" label to the left of the bottom pulley
          ctx.textAlign = "right";
          ctx.fillText(
            "Movable Pulley",
            movablePulleyX - movablePulleyRadius - 10,
            movablePulleyY
          );

          // Draw mechanical advantage indicator
          ctx.fillStyle = "#0066cc";
          ctx.font = "bold 16px Arial";
          ctx.textAlign = "left";
          ctx.fillText("Mechanical Advantage: " + ma + ":1", 20, height - 30);

          // Rope semicircle around top of smallest grey circle (from right to left)
          ctx.strokeStyle = "#8B4513";
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.moveTo(fixedPulleyX + smallerPulleyRadius, smallerPulleyY);
          // Arc along top semicircle from right (0°) to left (180°)
          // Split into two arcs: right to top, then top to left
          // First arc: from right (0°) to top (270°) going counterclockwise
          ctx.arc(
            fixedPulleyX,
            smallerPulleyY,
            smallerPulleyRadius,
            0, // Right side (0°)
            (3 * Math.PI) / 2, // Top (270°)
            true // Counterclockwise - goes from right through top
          );
          // Second arc: from top (270°) to left (180°) going counterclockwise
          ctx.arc(
            fixedPulleyX,
            smallerPulleyY,
            smallerPulleyRadius,
            (3 * Math.PI) / 2, // Top (270°)
            Math.PI, // Left side (180°)
            true // Counterclockwise - goes from top to left
          );
          ctx.stroke();

          // Brown line from left side of middle grey circle (second from top) to left side of second-from-bottom grey circle (only for 4:1)
          ctx.beginPath();
          ctx.moveTo(fixedPulleyX - smallerPulleyRadius, smallerPulleyY); // Left side of middle circle (second from top)
          ctx.lineTo(
            movablePulleyX - smallerBottomPulleyRadius,
            smallerBottomPulleyY
          ); // Left side of second-from-bottom circle
          ctx.stroke();

          // Semicircle around bottom of second-from-bottom grey circle (from left to right)
          ctx.beginPath();
          ctx.moveTo(
            movablePulleyX - smallerBottomPulleyRadius,
            smallerBottomPulleyY
          ); // Start at left side
          // Arc along bottom semicircle from left (180°) through bottom (270°) to right (0°)
          ctx.arc(
            movablePulleyX,
            smallerBottomPulleyY,
            smallerBottomPulleyRadius,
            Math.PI, // Left side (180°)
            0, // Right side (0°)
            true // Clockwise - goes from left through bottom (270°) to right (bottom semicircle)
          );
          ctx.stroke();

          // Line from right side of second-from-bottom grey circle to center of top grey circle (drawn before mount to appear behind)
          ctx.beginPath();
          ctx.moveTo(
            movablePulleyX + smallerBottomPulleyRadius,
            smallerBottomPulleyY
          ); // Right side of second-from-bottom circle
          ctx.lineTo(fixedPulleyX, fixedPulleyY); // Center of top grey circle
          ctx.stroke();

          // Draw extended pulley mount - rectangle that covers both pulleys with gap - BLACK
          const extendedMountHeight =
            smallerPulleyY +
            smallerPulleyRadius -
            (fixedPulleyY - mountHeight / 2);
          ctx.fillStyle = "#000";
          ctx.fillRect(
            fixedPulleyX - mountWidth / 2,
            fixedPulleyY - mountHeight / 2,
            mountWidth,
            extendedMountHeight
          );

          // Draw black rectangle connecting smaller bottom pulley to bottom movable pulley (only for 4:1)
          // This connects the two bottom pulleys with a gap
          const bottomExtendedMountHeight =
            movablePulleyY +
            movablePulleyRadius -
            (smallerBottomPulleyY - smallerBottomPulleyRadius);
          ctx.fillStyle = "#000";
          ctx.fillRect(
            movablePulleyX - bottomMountWidth / 2,
            smallerBottomPulleyY - smallerBottomPulleyRadius,
            bottomMountWidth,
            bottomExtendedMountHeight
          );
        }
      }

      // ========== PONG GAME CODE ==========
      // Canvas setup
      let pongCanvas = null;
      let pongCtx = null;

      // Game state
      let pongGameState = "start"; // 'start', 'playing', 'paused', 'gameOver'
      let pongPlayer1Score = 0;
      let pongPlayer2Score = 0;
      let pongBallSpeed = 5;
      let pongPaddleSpeed = 6;
      let pongTwoPlayerMode = false;
      let pongHardMode = false;
      let pongHitCount = 0; // Track hits against computer in single player mode (resets each round)
      let pongPlayerHighScore = 0; // Player's personal high score

      // Paddle properties
      const pongPaddleWidth = 15;
      const pongPaddleHeight = 80;

      // Player 1 paddle (left side)
      let pongPlayer1Paddle = {
        x: 20,
        y: 200,
        width: pongPaddleWidth,
        height: pongPaddleHeight,
        velocity: 0,
        acceleration: 0.6,
        friction: 0.995,
      };

      // Player 2 paddle (right side - AI controlled)
      let pongPlayer2Paddle = {
        x: 765,
        y: 200,
        width: pongPaddleWidth,
        height: pongPaddleHeight,
        velocity: 0,
        acceleration: 0.6,
        friction: 0.995,
      };

      // Ball properties
      let pongBall = {
        x: 400,
        y: 200,
        radius: 8,
        dx: 5,
        dy: 5,
      };

      // Input handling for pong
      const pongKeys = {};

      function initPongGame() {
        pongCanvas = document.getElementById("gameCanvas");
        if (!pongCanvas) return;
        pongCtx = pongCanvas.getContext("2d");
        
        // Reset paddle positions
        pongPlayer1Paddle.y = pongCanvas.height / 2 - pongPaddleHeight / 2;
        pongPlayer2Paddle.y = pongCanvas.height / 2 - pongPaddleHeight / 2;
        pongPlayer2Paddle.x = pongCanvas.width - 35;
        
        // Reset ball
        pongBall.x = pongCanvas.width / 2;
        pongBall.y = pongCanvas.height / 2;
        
        // Load player's high score
        loadPlayerHighScore();
        
        // Initial draw
        drawPong();
      }

      document.addEventListener("keydown", (e) => {
        pongKeys[e.key.toLowerCase()] = true;
        
        // Handle arrow keys
        if (e.key === "ArrowUp") {
          pongKeys["arrowup"] = true;
        }
        if (e.key === "ArrowDown") {
          pongKeys["arrowdown"] = true;
        }

        // Start game with spacebar
        if (e.key === " " && pongGameState === "start" && document.getElementById("pong-page")?.classList.contains("active")) {
          startPongGame();
        }

        // Pause game with spacebar
        if (e.key === " " && pongGameState === "playing" && document.getElementById("pong-page")?.classList.contains("active")) {
          togglePongPause();
        }
      });

      document.addEventListener("keyup", (e) => {
        pongKeys[e.key.toLowerCase()] = false;
        
        // Handle arrow keys
        if (e.key === "ArrowUp") {
          pongKeys["arrowup"] = false;
        }
        if (e.key === "ArrowDown") {
          pongKeys["arrowdown"] = false;
        }
      });

      // Game functions
      async function startPongGame() {
        pongGameState = "playing";
        const startScreen = document.getElementById("startScreen");
        const gameOver = document.getElementById("gameOver");
        if (startScreen) startScreen.style.display = "none";
        if (gameOver) gameOver.style.display = "none";
        pongHitCount = 0; // Reset hit count for new game
        updateCurrentHitsDisplay();
        await resetPongBall();
        pongGameLoop();
      }

      function resetPongGame() {
        pongPlayer1Score = 0;
        pongPlayer2Score = 0;
        pongHitCount = 0; // Reset hit count
        updatePongScore();
        updateCurrentHitsDisplay();
        startPongGame();
      }

      function togglePongPause() {
        if (pongGameState === "playing") {
          pongGameState = "paused";
        } else if (pongGameState === "paused") {
          pongGameState = "playing";
          pongGameLoop();
        }
      }

      async function resetPongBall() {
        if (!pongCanvas) return;
        // Check if this round's hits beat the high score (before resetting)
        if (!pongTwoPlayerMode && pongHitCount > 0) {
          if (pongHitCount > pongPlayerHighScore) {
            pongPlayerHighScore = pongHitCount;
            updatePlayerHighScoreDisplay();
            // Save to Firebase and wait for it to complete, then update leaderboard
            await savePongHighScore(pongHitCount);
          }
        }
        // Reset hit count for new round
        pongHitCount = 0;
        updateCurrentHitsDisplay();
        pongBall.x = pongCanvas.width / 2;
        pongBall.y = pongCanvas.height / 2;
        const direction = Math.random() > 0.5 ? 1 : -1;
        const angle = (Math.random() - 0.5) * Math.PI / 3;
        pongBall.dx = Math.cos(angle) * pongBallSpeed * direction;
        pongBall.dy = Math.sin(angle) * pongBallSpeed;
      }

      function updatePongScore() {
        const player1ScoreEl = document.getElementById("player1Score");
        const player2ScoreEl = document.getElementById("player2Score");
        if (player1ScoreEl) player1ScoreEl.textContent = pongPlayer1Score;
        if (player2ScoreEl) player2ScoreEl.textContent = pongPlayer2Score;
      }

      function updatePlayerHighScoreDisplay() {
        const highScoreEl = document.getElementById("playerHighScore");
        if (highScoreEl) {
          highScoreEl.textContent = pongPlayerHighScore;
        }
      }

      function updateCurrentHitsDisplay() {
        const currentHitsEl = document.getElementById("currentHits");
        if (currentHitsEl) {
          currentHitsEl.textContent = pongHitCount;
        }
      }

      async function checkPongGameOver() {
        if (pongPlayer1Score >= 5 || pongPlayer2Score >= 5) {
          pongGameState = "gameOver";
          const gameOver = document.getElementById("gameOver");
          const gameOverText = document.getElementById("gameOverText");
          const winnerText = document.getElementById("winnerText");
          if (gameOver) gameOver.style.display = "block";
          if (gameOverText) gameOverText.textContent = "Game Over!";
          if (winnerText) {
            winnerText.textContent = pongPlayer1Score >= 5 ? "You Win!" : "Computer Wins!";
          }
          // Check final round's hits before game ends
          if (!pongTwoPlayerMode && pongHitCount > 0) {
            if (pongHitCount > pongPlayerHighScore) {
              pongPlayerHighScore = pongHitCount;
              updatePlayerHighScoreDisplay();
              // Save to Firebase and wait for it to complete, then update leaderboard
              await savePongHighScore(pongHitCount);
            }
          }
        }
      }

      function updatePongPlayer1Paddle() {
        if (!pongCanvas || !document.getElementById("pong-page")?.classList.contains("active")) return;
        if (pongHardMode) {
          const acceleration = pongPlayer1Paddle.acceleration * (pongPaddleSpeed / 6);
          if (pongKeys["w"]) {
            pongPlayer1Paddle.velocity -= acceleration;
          }
          if (pongKeys["s"]) {
            pongPlayer1Paddle.velocity += acceleration;
          }
          pongPlayer1Paddle.velocity *= pongPlayer1Paddle.friction;
          pongPlayer1Paddle.y += pongPlayer1Paddle.velocity;
          if (pongPlayer1Paddle.y < 0) {
            pongPlayer1Paddle.y = 0;
            pongPlayer1Paddle.velocity *= -0.5;
          }
          if (pongPlayer1Paddle.y + pongPlayer1Paddle.height > pongCanvas.height) {
            pongPlayer1Paddle.y = pongCanvas.height - pongPlayer1Paddle.height;
            pongPlayer1Paddle.velocity *= -0.5;
          }
        } else {
          if (pongKeys["w"]) {
            pongPlayer1Paddle.y -= pongPaddleSpeed;
          }
          if (pongKeys["s"]) {
            pongPlayer1Paddle.y += pongPaddleSpeed;
          }
          if (pongPlayer1Paddle.y < 0) {
            pongPlayer1Paddle.y = 0;
          }
          if (pongPlayer1Paddle.y + pongPlayer1Paddle.height > pongCanvas.height) {
            pongPlayer1Paddle.y = pongCanvas.height - pongPlayer1Paddle.height;
          }
        }
      }

      function updatePongPlayer2Paddle() {
        if (!pongCanvas || !document.getElementById("pong-page")?.classList.contains("active")) return;
        if (pongTwoPlayerMode) {
          if (pongHardMode) {
            const acceleration = pongPlayer2Paddle.acceleration * (pongPaddleSpeed / 6);
            if (pongKeys["arrowup"]) {
              pongPlayer2Paddle.velocity -= acceleration;
            }
            if (pongKeys["arrowdown"]) {
              pongPlayer2Paddle.velocity += acceleration;
            }
            pongPlayer2Paddle.velocity *= pongPlayer2Paddle.friction;
            pongPlayer2Paddle.y += pongPlayer2Paddle.velocity;
            if (pongPlayer2Paddle.y < 0) {
              pongPlayer2Paddle.y = 0;
              pongPlayer2Paddle.velocity *= -0.5;
            }
            if (pongPlayer2Paddle.y + pongPlayer2Paddle.height > pongCanvas.height) {
              pongPlayer2Paddle.y = pongCanvas.height - pongPlayer2Paddle.height;
              pongPlayer2Paddle.velocity *= -0.5;
            }
          } else {
            if (pongKeys["arrowup"]) {
              pongPlayer2Paddle.y -= pongPaddleSpeed;
            }
            if (pongKeys["arrowdown"]) {
              pongPlayer2Paddle.y += pongPaddleSpeed;
            }
            if (pongPlayer2Paddle.y < 0) {
              pongPlayer2Paddle.y = 0;
            }
            if (pongPlayer2Paddle.y + pongPlayer2Paddle.height > pongCanvas.height) {
              pongPlayer2Paddle.y = pongCanvas.height - pongPlayer2Paddle.height;
            }
          }
        } else {
          if (pongHardMode) {
            const acceleration = pongPlayer2Paddle.acceleration * (pongPaddleSpeed / 6) * 0.8;
            const paddleCenter = pongPlayer2Paddle.y + pongPlayer2Paddle.height / 2;
            const ballY = pongBall.y;
            if (ballY < paddleCenter - 10) {
              pongPlayer2Paddle.velocity -= acceleration;
            } else if (ballY > paddleCenter + 10) {
              pongPlayer2Paddle.velocity += acceleration;
            }
            pongPlayer2Paddle.velocity *= pongPlayer2Paddle.friction;
            pongPlayer2Paddle.y += pongPlayer2Paddle.velocity;
            if (pongPlayer2Paddle.y < 0) {
              pongPlayer2Paddle.y = 0;
              pongPlayer2Paddle.velocity *= -0.5;
            }
            if (pongPlayer2Paddle.y + pongPlayer2Paddle.height > pongCanvas.height) {
              pongPlayer2Paddle.y = pongCanvas.height - pongPlayer2Paddle.height;
              pongPlayer2Paddle.velocity *= -0.5;
            }
          } else {
            const paddleCenter = pongPlayer2Paddle.y + pongPlayer2Paddle.height / 2;
            const ballY = pongBall.y;
            if (ballY < paddleCenter - 10) {
              pongPlayer2Paddle.y -= pongPaddleSpeed * 0.85;
            } else if (ballY > paddleCenter + 10) {
              pongPlayer2Paddle.y += pongPaddleSpeed * 0.85;
            }
            if (pongPlayer2Paddle.y < 0) {
              pongPlayer2Paddle.y = 0;
            }
            if (pongPlayer2Paddle.y + pongPlayer2Paddle.height > pongCanvas.height) {
              pongPlayer2Paddle.y = pongCanvas.height - pongPlayer2Paddle.height;
            }
          }
        }
      }

      function togglePlayerMode() {
        pongTwoPlayerMode = !pongTwoPlayerMode;
        const button = document.getElementById("modeToggle");
        const controlsText = document.querySelector(".pong-controls");
        pongPlayer1Paddle.velocity = 0;
        pongPlayer2Paddle.velocity = 0;
        if (pongTwoPlayerMode) {
          if (button) button.textContent = "Mode: Two Player";
          button?.classList.add("two-player");
          if (controlsText) controlsText.textContent = "Player 1: W/S keys | Player 2: ↑/↓ arrows";
        } else {
          if (button) button.textContent = "Mode: Single Player";
          button?.classList.remove("two-player");
          if (controlsText) controlsText.textContent = "Use W/S keys to move your paddle";
        }
      }

      function toggleHardMode() {
        pongHardMode = !pongHardMode;
        const button = document.getElementById("hardModeToggle");
        if (pongHardMode) {
          if (button) button.textContent = "Hard Mode: ON";
          button?.classList.add("active");
        } else {
          if (button) button.textContent = "Hard Mode: OFF";
          button?.classList.remove("active");
          pongPlayer1Paddle.velocity = 0;
          pongPlayer2Paddle.velocity = 0;
        }
      }

      async function updatePongBall() {
        if (!pongCanvas) return;
        pongBall.x += pongBall.dx;
        pongBall.y += pongBall.dy;
        
        // Top wall collision - ensure ball bounces away
        if (pongBall.y - pongBall.radius <= 0) {
          pongBall.y = pongBall.radius; // Move ball back to boundary
          pongBall.dy = Math.abs(pongBall.dy); // Ensure it moves down (away from wall)
        }
        
        // Bottom wall collision - ensure ball bounces away
        if (pongBall.y + pongBall.radius >= pongCanvas.height) {
          pongBall.y = pongCanvas.height - pongBall.radius; // Move ball back to boundary
          pongBall.dy = -Math.abs(pongBall.dy); // Ensure it moves up (away from wall)
        }
        if (
          pongBall.x - pongBall.radius <= pongPlayer1Paddle.x + pongPlayer1Paddle.width &&
          pongBall.y >= pongPlayer1Paddle.y &&
          pongBall.y <= pongPlayer1Paddle.y + pongPlayer1Paddle.height &&
          pongBall.dx < 0
        ) {
          const hitPos = (pongBall.y - pongPlayer1Paddle.y) / pongPlayer1Paddle.height;
          const angle = ((hitPos - 0.5) * Math.PI) / 3;
          pongBall.dx = Math.cos(angle) * pongBallSpeed;
          pongBall.dy = Math.sin(angle) * pongBallSpeed;
          pongBall.x = pongPlayer1Paddle.x + pongPlayer1Paddle.width + pongBall.radius;
          // Track hits in single player mode
          if (!pongTwoPlayerMode) {
            pongHitCount++;
            updateCurrentHitsDisplay();
          }
        }
        if (
          pongBall.x + pongBall.radius >= pongPlayer2Paddle.x &&
          pongBall.y >= pongPlayer2Paddle.y &&
          pongBall.y <= pongPlayer2Paddle.y + pongPlayer2Paddle.height &&
          pongBall.dx > 0
        ) {
          const hitPos = (pongBall.y - pongPlayer2Paddle.y) / pongPlayer2Paddle.height;
          const angle = ((hitPos - 0.5) * Math.PI) / 3;
          pongBall.dx = -Math.cos(angle) * pongBallSpeed;
          pongBall.dy = Math.sin(angle) * pongBallSpeed;
          pongBall.x = pongPlayer2Paddle.x - pongBall.radius;
        }
        if (pongBall.x < 0) {
          pongPlayer2Score++;
          updatePongScore();
          await checkPongGameOver();
          if (pongGameState === "playing") {
            await resetPongBall();
          }
        } else if (pongBall.x > pongCanvas.width) {
          pongPlayer1Score++;
          updatePongScore();
          await checkPongGameOver();
          if (pongGameState === "playing") {
            await resetPongBall();
          }
        }
      }

      function drawPong() {
        if (!pongCanvas || !pongCtx) return;
        pongCtx.fillStyle = "#000";
        pongCtx.fillRect(0, 0, pongCanvas.width, pongCanvas.height);
        pongCtx.setLineDash([10, 10]);
        pongCtx.strokeStyle = "#fff";
        pongCtx.lineWidth = 2;
        pongCtx.beginPath();
        pongCtx.moveTo(pongCanvas.width / 2, 0);
        pongCtx.lineTo(pongCanvas.width / 2, pongCanvas.height);
        pongCtx.stroke();
        pongCtx.setLineDash([]);
        pongCtx.fillStyle = "#fff";
        pongCtx.fillRect(
          pongPlayer1Paddle.x,
          pongPlayer1Paddle.y,
          pongPlayer1Paddle.width,
          pongPlayer1Paddle.height
        );
        pongCtx.fillRect(
          pongPlayer2Paddle.x,
          pongPlayer2Paddle.y,
          pongPlayer2Paddle.width,
          pongPlayer2Paddle.height
        );
        pongCtx.beginPath();
        pongCtx.arc(pongBall.x, pongBall.y, pongBall.radius, 0, Math.PI * 2);
        pongCtx.fillStyle = "#fff";
        pongCtx.fill();
        if (pongGameState === "paused") {
          pongCtx.fillStyle = "rgba(0, 0, 0, 0.7)";
          pongCtx.fillRect(0, 0, pongCanvas.width, pongCanvas.height);
          pongCtx.fillStyle = "#fff";
          pongCtx.font = "48px Arial";
          pongCtx.textAlign = "center";
          pongCtx.fillText("PAUSED", pongCanvas.width / 2, pongCanvas.height / 2);
          pongCtx.font = "16px Arial";
          pongCtx.fillText(
            "Press SPACE to resume",
            pongCanvas.width / 2,
            pongCanvas.height / 2 + 40
          );
        }
      }

      function pongGameLoop() {
        if (pongGameState === "playing") {
          updatePongPlayer1Paddle();
          updatePongPlayer2Paddle();
          updatePongBall();
          drawPong();
          requestAnimationFrame(pongGameLoop);
        } else if (pongGameState === "paused") {
          drawPong();
        }
      }

      // Speed slider functionality
      const speedSlider = document.getElementById("speedSlider");
      const speedValue = document.getElementById("speedValue");
      if (speedSlider && speedValue) {
        speedSlider.addEventListener("input", function () {
          pongBallSpeed = parseFloat(this.value);
          speedValue.textContent = pongBallSpeed;
          if (pongGameState === "playing") {
            const currentSpeed = Math.sqrt(pongBall.dx * pongBall.dx + pongBall.dy * pongBall.dy);
            if (currentSpeed > 0) {
              const angle = Math.atan2(pongBall.dy, pongBall.dx);
              pongBall.dx = Math.cos(angle) * pongBallSpeed;
              pongBall.dy = Math.sin(angle) * pongBallSpeed;
            }
          }
        });
      }

      // Paddle speed slider functionality
      const paddleSpeedSlider = document.getElementById("paddleSpeedSlider");
      const paddleSpeedValue = document.getElementById("paddleSpeedValue");
      if (paddleSpeedSlider && paddleSpeedValue) {
        paddleSpeedSlider.addEventListener("input", function () {
          pongPaddleSpeed = parseFloat(this.value);
          paddleSpeedValue.textContent = pongPaddleSpeed;
        });
      }

      // Firebase high score functions
      async function loadPlayerHighScore() {
        const username = getUsername();
        if (!username) {
          // Try to load from localStorage as fallback
          const savedHighScore = localStorage.getItem('pongHighScore');
          if (savedHighScore) {
            pongPlayerHighScore = parseInt(savedHighScore) || 0;
            updatePlayerHighScoreDisplay();
          }
          return;
        }

        // Try to load from localStorage first (faster)
        const savedHighScore = localStorage.getItem(`pongHighScore_${username}`);
        if (savedHighScore) {
          pongPlayerHighScore = parseInt(savedHighScore) || 0;
          updatePlayerHighScoreDisplay();
        }

        // Then load from Firebase to get the latest
        if (!window.firestoreDb) {
          return;
        }

        try {
          const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
          const leaderboardRef = doc(window.firestoreDb, 'Leaderboard', username);
          const currentDoc = await getDoc(leaderboardRef);
          
          if (currentDoc.exists()) {
            const score = currentDoc.data().score || 0;
            pongPlayerHighScore = score;
            updatePlayerHighScoreDisplay();
            // Save to localStorage for persistence
            localStorage.setItem(`pongHighScore_${username}`, score.toString());
          }
        } catch (error) {
          console.error('Error loading player high score:', error);
        }
      }

      async function savePongHighScore(hits) {
        if (!window.firestoreDb) {
          console.error('❌ Firestore not initialized');
          return false;
        }

        const username = getUsername();
        if (!username) {
          console.error('❌ No username found');
          return false;
        }

        try {
          const { setDoc, doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
          
          // Get current high score for this user
          const leaderboardRef = doc(window.firestoreDb, 'Leaderboard', username);
          
          // Check if user already has a high score
          const currentDoc = await getDoc(leaderboardRef);
          
          let shouldUpdate = false;
          let currentScore = 0;
          
          if (!currentDoc.exists()) {
            // No existing score, save this one
            shouldUpdate = true;
            console.log(`📝 No existing score for ${username}, saving ${hits} hits`);
          } else {
            currentScore = currentDoc.data().score || 0;
            if (hits > currentScore) {
              // New high score!
              shouldUpdate = true;
              console.log(`🎉 New high score! ${hits} > ${currentScore} for ${username}`);
            } else {
              console.log(`⏭️ Score ${hits} not higher than current Firebase score ${currentScore}, skipping save`);
            }
          }

          if (shouldUpdate) {
            // Always save/update the score field in Firebase when it's a new high score
            // Using setDoc with merge: true ensures the score field gets updated
            await setDoc(leaderboardRef, {
              score: hits
            }, { merge: true });
            console.log(`✅ Successfully saved/updated score field in Firebase: ${hits} hits for ${username}`);
            
            // Verify the score was saved correctly by reading it back
            const verifyDoc = await getDoc(leaderboardRef);
            if (verifyDoc.exists()) {
              const savedScore = verifyDoc.data().score;
              console.log(`✅ Verified: Score field in Firebase is now ${savedScore} for ${username}`);
              if (savedScore !== hits) {
                console.warn(`⚠️ Warning: Saved score ${savedScore} doesn't match expected ${hits}`);
              }
            }
            
            // Save to localStorage for persistence
            localStorage.setItem(`pongHighScore_${username}`, hits.toString());
            
            // Small delay to ensure Firebase has propagated the change
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Always reload leaderboard after saving to update the table
            console.log('🔄 Reloading leaderboard table after save...');
            try {
              await loadPongLeaderboard();
              console.log('✅ Leaderboard table updated after save!');
            } catch (reloadError) {
              console.error('❌ Error reloading leaderboard after save:', reloadError);
              // Try again after a delay
              setTimeout(async () => {
                console.log('🔄 Retrying leaderboard reload...');
                await loadPongLeaderboard();
              }, 500);
            }
            return true;
          }
          return false;
        } catch (error) {
          console.error('❌ Error saving high score:', error);
          // Try to reload leaderboard even if save failed
          try {
            await loadPongLeaderboard();
          } catch (reloadError) {
            console.error('❌ Error reloading leaderboard:', reloadError);
          }
          return false;
        }
      }

      // Make loadPongLeaderboard globally accessible
      window.loadPongLeaderboard = async function loadPongLeaderboard() {
        console.log('🔄 loadPongLeaderboard() called');
        
        if (!window.firestoreDb) {
          console.error('❌ Firestore not initialized for leaderboard');
          // Retry after a delay if Firestore isn't ready
          setTimeout(() => {
            if (window.firestoreDb) {
              loadPongLeaderboard();
            }
          }, 500);
          return;
        }

        const loadingEl = document.getElementById("leaderboard-loading");
        const tableEl = document.getElementById("leaderboard-table");
        const tbodyEl = document.getElementById("leaderboard-body");

        if (!loadingEl) {
          console.error('❌ leaderboard-loading element not found');
          return;
        }
        if (!tableEl) {
          console.error('❌ leaderboard-table element not found');
          return;
        }
        if (!tbodyEl) {
          console.error('❌ leaderboard-body element not found');
          return;
        }

        try {
          console.log('📊 Starting to load leaderboard...');
          loadingEl.style.display = "block";
          loadingEl.textContent = "Loading leaderboard...";
          tableEl.style.display = "none";

          const { getDocs, collection, query, orderBy, limit } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
          const leaderboardRef = collection(window.firestoreDb, 'Leaderboard');
          
          console.log('📊 Querying Leaderboard collection...');
          // Query top 5 scores ordered by score descending
          const q = query(leaderboardRef, orderBy('score', 'desc'), limit(5));
          const querySnapshot = await getDocs(q);

          console.log(`📊 Loaded ${querySnapshot.size} scores from leaderboard`);

          // Clear existing rows
          tbodyEl.innerHTML = "";

          if (querySnapshot.empty) {
            console.log('📊 Leaderboard is empty - no scores found');
            tbodyEl.innerHTML = "<tr><td colspan='3' style='text-align: center; color: rgba(255,255,255,0.7);'>No high scores yet!</td></tr>";
            loadingEl.style.display = "none";
            tableEl.style.display = "table";
          } else {
            let rank = 1;
            const scores = [];
            querySnapshot.forEach((doc) => {
              const data = doc.data();
              const score = data.score || 0;
              scores.push({ name: doc.id, score: score });
              console.log(`📊 Rank ${rank}: ${doc.id} - ${score} hits`);
              const row = document.createElement("tr");
              row.innerHTML = `
                <td class="rank">${rank}</td>
                <td class="name">${doc.id}</td>
                <td class="hits">${score}</td>
              `;
              tbodyEl.appendChild(row);
              rank++;
            });
            
            console.log(`✅ Added ${scores.length} rows to leaderboard table`);
            
            // Hide loading and show table
            loadingEl.style.display = "none";
            tableEl.style.display = "table";
            console.log('✅ Leaderboard table displayed with', scores.length, 'scores');
          }
        } catch (error) {
          console.error('❌ Error loading leaderboard:', error);
          console.error('Error details:', error.message, error.stack);
          
          if (loadingEl) {
            loadingEl.textContent = `Error loading leaderboard: ${error.message}`;
            loadingEl.style.display = "block";
          }
          if (tableEl) {
            tableEl.style.display = "none";
          }
          
          // Try to reload after a delay
          setTimeout(() => {
            console.log('🔄 Retrying leaderboard load...');
            loadPongLeaderboard();
          }, 2000);
        }
      }

      // Initialize user's leaderboard entry with score 0 if they don't exist
      async function initializeUserLeaderboardEntry() {
        if (!window.firestoreDb) {
          console.error('❌ Firestore not initialized');
          return;
        }

        const username = getUsername();
        if (!username) {
          console.error('❌ No username found');
          return;
        }

        try {
          const { setDoc, doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
          const leaderboardRef = doc(window.firestoreDb, 'Leaderboard', username);
          
          // Check if user already has an entry
          const currentDoc = await getDoc(leaderboardRef);
          
          if (!currentDoc.exists()) {
            // User doesn't exist in leaderboard, create entry with score 0
            await setDoc(leaderboardRef, {
              score: 0
            });
            console.log(`✅ Initialized leaderboard entry for ${username} with score 0`);
            // Reload leaderboard to show the new entry
            await loadPongLeaderboard();
          } else {
            console.log(`✅ User ${username} already exists in leaderboard with score ${currentDoc.data().score || 0}`);
          }
        } catch (error) {
          console.error('❌ Error initializing user leaderboard entry:', error);
        }
      }

      // ========== END PONG GAME CODE ==========
    </script>
  </body>
</html>

